/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace de { namespace tum { namespace in { namespace i22 { namespace uc { namespace thrift { namespace types {

struct TStatus {
  enum type {
    OKAY = 1,
    ERROR = 2,
    ALLOW = 3,
    INHIBIT = 4,
    MODIFY = 5,
    ERROR_EVENT_PARAMETER_MISSING = 6
  };
};

extern const std::map<int, const char*> _TStatus_VALUES_TO_NAMES;

struct TDetectionMode {
  enum type {
    MISUSE = 1,
    ANOMALY = 2,
    COMBINED = 3
  };
};

extern const std::map<int, const char*> _TDetectionMode_VALUES_TO_NAMES;

struct TConflictResolution {
  enum type {
    OVERWRITE = 1,
    IGNORE_UPDATES = 2,
    KEEP_ALL = 3
  };
};

extern const std::map<int, const char*> _TConflictResolution_VALUES_TO_NAMES;

struct TAttributeName {
  enum type {
    WILDCARD = 1,
    TYPE = 2,
    OWNER = 3,
    CLASS = 4,
    CREATION_TIME = 5,
    MODIFICATION_TIME = 6,
    SIZE = 7
  };
};

extern const std::map<int, const char*> _TAttributeName_VALUES_TO_NAMES;

struct TobiasStatusType {
  enum type {
    OK = 1,
    ERROR = 2,
    ALLOW = 3,
    INHIBIT = 4,
    MODIFY = 5
  };
};

extern const std::map<int, const char*> _TobiasStatusType_VALUES_TO_NAMES;

typedef int64_t tlong;

typedef int32_t tint;


class TAttribute {
 public:

  static const char* ascii_fingerprint; // = "19B5240589E680301A7E32DF3971EFBE";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

  TAttribute() : name((TAttributeName::type)0), value() {
  }

  virtual ~TAttribute() throw() {}

  TAttributeName::type name;
  std::string value;

  void __set_name(const TAttributeName::type val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TAttribute & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAttribute &a, TAttribute &b);

typedef struct _TEvent__isset {
  _TEvent__isset() : parameters(false), timeStamp(false), isActual(true), comment(false) {}
  bool parameters;
  bool timeStamp;
  bool isActual;
  bool comment;
} _TEvent__isset;

class TEvent {
 public:

  static const char* ascii_fingerprint; // = "FB0E396919623C457DA1EE3225CBD1A0";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x0E,0x39,0x69,0x19,0x62,0x3C,0x45,0x7D,0xA1,0xEE,0x32,0x25,0xCB,0xD1,0xA0};

  TEvent() : name(), timeStamp(0), isActual(false), comment() {
  }

  virtual ~TEvent() throw() {}

  std::string name;
  std::map<std::string, std::string>  parameters;
  tlong timeStamp;
  bool isActual;
  std::string comment;

  _TEvent__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_timeStamp(const tlong val) {
    timeStamp = val;
  }

  void __set_isActual(const bool val) {
    isActual = val;
    __isset.isActual = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TEvent & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(timeStamp == rhs.timeStamp))
      return false;
    if (__isset.isActual != rhs.__isset.isActual)
      return false;
    else if (__isset.isActual && !(isActual == rhs.isActual))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TEvent &a, TEvent &b);

typedef struct _TResponse__isset {
  _TResponse__isset() : status(false), executeEvents(false), modifiedEvents(false), comment(false) {}
  bool status;
  bool executeEvents;
  bool modifiedEvents;
  bool comment;
} _TResponse__isset;

class TResponse {
 public:

  static const char* ascii_fingerprint; // = "E9C129C579FFEDD7607C3917C93B4AED";
  static const uint8_t binary_fingerprint[16]; // = {0xE9,0xC1,0x29,0xC5,0x79,0xFF,0xED,0xD7,0x60,0x7C,0x39,0x17,0xC9,0x3B,0x4A,0xED};

  TResponse() : status((TStatus::type)0), comment() {
  }

  virtual ~TResponse() throw() {}

  TStatus::type status;
  std::vector<TEvent>  executeEvents;
  TEvent modifiedEvents;
  std::string comment;

  _TResponse__isset __isset;

  void __set_status(const TStatus::type val) {
    status = val;
  }

  void __set_executeEvents(const std::vector<TEvent> & val) {
    executeEvents = val;
    __isset.executeEvents = true;
  }

  void __set_modifiedEvents(const TEvent& val) {
    modifiedEvents = val;
    __isset.modifiedEvents = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TResponse & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.executeEvents != rhs.__isset.executeEvents)
      return false;
    else if (__isset.executeEvents && !(executeEvents == rhs.executeEvents))
      return false;
    if (__isset.modifiedEvents != rhs.__isset.modifiedEvents)
      return false;
    else if (__isset.modifiedEvents && !(modifiedEvents == rhs.modifiedEvents))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TResponse &a, TResponse &b);

typedef struct _TPxpSpec__isset {
  _TPxpSpec__isset() : ip(false), port(false), description(false), id(false) {}
  bool ip;
  bool port;
  bool description;
  bool id;
} _TPxpSpec__isset;

class TPxpSpec {
 public:

  static const char* ascii_fingerprint; // = "12835D589BEF997E7FB3259F7A7D1795";
  static const uint8_t binary_fingerprint[16]; // = {0x12,0x83,0x5D,0x58,0x9B,0xEF,0x99,0x7E,0x7F,0xB3,0x25,0x9F,0x7A,0x7D,0x17,0x95};

  TPxpSpec() : ip(), port(0), description(), id() {
  }

  virtual ~TPxpSpec() throw() {}

  std::string ip;
  tint port;
  std::string description;
  std::string id;

  _TPxpSpec__isset __isset;

  void __set_ip(const std::string& val) {
    ip = val;
  }

  void __set_port(const tint val) {
    port = val;
  }

  void __set_description(const std::string& val) {
    description = val;
  }

  void __set_id(const std::string& val) {
    id = val;
  }

  bool operator == (const TPxpSpec & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TPxpSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPxpSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPxpSpec &a, TPxpSpec &b);


class TContainer {
 public:

  static const char* ascii_fingerprint; // = "C28054E479AC176DCB75B579BDF4FBCC";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0x80,0x54,0xE4,0x79,0xAC,0x17,0x6D,0xCB,0x75,0xB5,0x79,0xBD,0xF4,0xFB,0xCC};

  TContainer() : id() {
  }

  virtual ~TContainer() throw() {}

  std::string id;
  std::vector<TAttribute>  attributes;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_attributes(const std::vector<TAttribute> & val) {
    attributes = val;
  }

  bool operator == (const TContainer & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const TContainer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TContainer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TContainer &a, TContainer &b);


class TData {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TData() : id() {
  }

  virtual ~TData() throw() {}

  std::string id;

  void __set_id(const std::string& val) {
    id = val;
  }

  bool operator == (const TData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TData &a, TData &b);


class TName {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TName() : name() {
  }

  virtual ~TName() throw() {}

  std::string name;

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const TName & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const TName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TName &a, TName &b);

typedef struct _TXmlPolicy__isset {
  _TXmlPolicy__isset() : description(false), templateId(false), templateXml(false), dataClass(false) {}
  bool description;
  bool templateId;
  bool templateXml;
  bool dataClass;
} _TXmlPolicy__isset;

class TXmlPolicy {
 public:

  static const char* ascii_fingerprint; // = "873CB9E5A4C10A7ECE7476FD192F55EE";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x3C,0xB9,0xE5,0xA4,0xC1,0x0A,0x7E,0xCE,0x74,0x76,0xFD,0x19,0x2F,0x55,0xEE};

  TXmlPolicy() : name(), xml(), description(), templateId(), templateXml(), dataClass() {
  }

  virtual ~TXmlPolicy() throw() {}

  std::string name;
  std::string xml;
  std::string description;
  std::string templateId;
  std::string templateXml;
  std::string dataClass;

  _TXmlPolicy__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_xml(const std::string& val) {
    xml = val;
  }

  void __set_description(const std::string& val) {
    description = val;
  }

  void __set_templateId(const std::string& val) {
    templateId = val;
  }

  void __set_templateXml(const std::string& val) {
    templateXml = val;
  }

  void __set_dataClass(const std::string& val) {
    dataClass = val;
  }

  bool operator == (const TXmlPolicy & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(xml == rhs.xml))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(templateId == rhs.templateId))
      return false;
    if (!(templateXml == rhs.templateXml))
      return false;
    if (!(dataClass == rhs.dataClass))
      return false;
    return true;
  }
  bool operator != (const TXmlPolicy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TXmlPolicy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TXmlPolicy &a, TXmlPolicy &b);

typedef struct _TPtpResponse__isset {
  _TPtpResponse__isset() : policy(false), status(false) {}
  bool policy;
  bool status;
} _TPtpResponse__isset;

class TPtpResponse {
 public:

  static const char* ascii_fingerprint; // = "D508CACD59422D80A6BD2586FD093B70";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x08,0xCA,0xCD,0x59,0x42,0x2D,0x80,0xA6,0xBD,0x25,0x86,0xFD,0x09,0x3B,0x70};

  TPtpResponse() : status((TStatus::type)0) {
  }

  virtual ~TPtpResponse() throw() {}

  TXmlPolicy policy;
  TStatus::type status;

  _TPtpResponse__isset __isset;

  void __set_policy(const TXmlPolicy& val) {
    policy = val;
  }

  void __set_status(const TStatus::type val) {
    status = val;
  }

  bool operator == (const TPtpResponse & rhs) const
  {
    if (!(policy == rhs.policy))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TPtpResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPtpResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPtpResponse &a, TPtpResponse &b);

typedef struct _TobiasEvent__isset {
  _TobiasEvent__isset() : name(false), parameters(false), timeStamp(false), comment(false) {}
  bool name;
  bool parameters;
  bool timeStamp;
  bool comment;
} _TobiasEvent__isset;

class TobiasEvent {
 public:

  static const char* ascii_fingerprint; // = "4D1D5DC6D6DC1885A743999D0C0DB4BB";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0x1D,0x5D,0xC6,0xD6,0xDC,0x18,0x85,0xA7,0x43,0x99,0x9D,0x0C,0x0D,0xB4,0xBB};

  TobiasEvent() : name(), timeStamp(0), comment() {
  }

  virtual ~TobiasEvent() throw() {}

  std::string name;
  std::map<std::string, std::string>  parameters;
  tlong timeStamp;
  std::string comment;

  _TobiasEvent__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_timeStamp(const tlong val) {
    timeStamp = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TobiasEvent & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(timeStamp == rhs.timeStamp))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TobiasEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TobiasEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TobiasEvent &a, TobiasEvent &b);

typedef struct _TobiasResponse__isset {
  _TobiasResponse__isset() : status(false), executeEvents(false), modifiedEvents(false), comment(false) {}
  bool status;
  bool executeEvents;
  bool modifiedEvents;
  bool comment;
} _TobiasResponse__isset;

class TobiasResponse {
 public:

  static const char* ascii_fingerprint; // = "1DE6F50E382F99625B6945AF7DE2416E";
  static const uint8_t binary_fingerprint[16]; // = {0x1D,0xE6,0xF5,0x0E,0x38,0x2F,0x99,0x62,0x5B,0x69,0x45,0xAF,0x7D,0xE2,0x41,0x6E};

  TobiasResponse() : status((TobiasStatusType::type)0), comment() {
  }

  virtual ~TobiasResponse() throw() {}

  TobiasStatusType::type status;
  std::vector<TobiasEvent>  executeEvents;
  TobiasEvent modifiedEvents;
  std::string comment;

  _TobiasResponse__isset __isset;

  void __set_status(const TobiasStatusType::type val) {
    status = val;
  }

  void __set_executeEvents(const std::vector<TobiasEvent> & val) {
    executeEvents = val;
    __isset.executeEvents = true;
  }

  void __set_modifiedEvents(const TobiasEvent& val) {
    modifiedEvents = val;
    __isset.modifiedEvents = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TobiasResponse & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.executeEvents != rhs.__isset.executeEvents)
      return false;
    else if (__isset.executeEvents && !(executeEvents == rhs.executeEvents))
      return false;
    if (__isset.modifiedEvents != rhs.__isset.modifiedEvents)
      return false;
    else if (__isset.modifiedEvents && !(modifiedEvents == rhs.modifiedEvents))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TobiasResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TobiasResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TobiasResponse &a, TobiasResponse &b);

}}}}}}} // namespace

#endif
