/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace de { namespace tum { namespace in { namespace i22 { namespace uc { namespace thrift { namespace types {

struct TStatus {
  enum type {
    OKAY = 1,
    ERROR = 2,
    ALLOW = 3,
    INHIBIT = 4,
    MODIFY = 5,
    ERROR_EVENT_PARAMETER_MISSING = 6
  };
};

extern const std::map<int, const char*> _TStatus_VALUES_TO_NAMES;

struct TDetectionMode {
  enum type {
    MISUSE = 1,
    ANOMALY = 2,
    COMBINED = 3
  };
};

extern const std::map<int, const char*> _TDetectionMode_VALUES_TO_NAMES;

struct TConflictResolution {
  enum type {
    OVERWRITE = 1,
    IGNORE_UPDATES = 2,
    KEEP_ALL = 3
  };
};

extern const std::map<int, const char*> _TConflictResolution_VALUES_TO_NAMES;

struct TAttributeName {
  enum type {
    WILDCARD = 1,
    TYPE = 2,
    OWNER = 3,
    CLASS = 4,
    CREATION_TIME = 5,
    MODIFICATION_TIME = 6,
    SIZE = 7
  };
};

extern const std::map<int, const char*> _TAttributeName_VALUES_TO_NAMES;

struct TobiasStatusType {
  enum type {
    OK = 1,
    ERROR = 2,
    ALLOW = 3,
    INHIBIT = 4,
    MODIFY = 5
  };
};

extern const std::map<int, const char*> _TobiasStatusType_VALUES_TO_NAMES;

typedef int64_t tlong;

typedef int32_t tint;

class TChecksum;

class TAttribute;

class TEvent;

class TResponse;

class TPxpSpec;

class TContainer;

class TData;

class TName;

class TXmlPolicy;

class TPtpResponse;

class TobiasEvent;

class TobiasResponse;


class TChecksum {
 public:

  TChecksum(const TChecksum&);
  TChecksum& operator=(const TChecksum&);
  TChecksum() : val(0) {
  }

  virtual ~TChecksum() throw();
  tlong val;

  void __set_val(const tlong val);

  bool operator == (const TChecksum & rhs) const
  {
    if (!(val == rhs.val))
      return false;
    return true;
  }
  bool operator != (const TChecksum &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TChecksum & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TChecksum &a, TChecksum &b);

inline std::ostream& operator<<(std::ostream& out, const TChecksum& obj)
{
  obj.printTo(out);
  return out;
}


class TAttribute {
 public:

  TAttribute(const TAttribute&);
  TAttribute& operator=(const TAttribute&);
  TAttribute() : name((TAttributeName::type)0), value() {
  }

  virtual ~TAttribute() throw();
  TAttributeName::type name;
  std::string value;

  void __set_name(const TAttributeName::type val);

  void __set_value(const std::string& val);

  bool operator == (const TAttribute & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TAttribute &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAttribute & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAttribute &a, TAttribute &b);

inline std::ostream& operator<<(std::ostream& out, const TAttribute& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TEvent__isset {
  _TEvent__isset() : parameters(false), isActual(false) {}
  bool parameters :1;
  bool isActual :1;
} _TEvent__isset;

class TEvent {
 public:

  TEvent(const TEvent&);
  TEvent& operator=(const TEvent&);
  TEvent() : name(), isActual(0) {
  }

  virtual ~TEvent() throw();
  std::string name;
  std::map<std::string, std::string>  parameters;
  bool isActual;

  _TEvent__isset __isset;

  void __set_name(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_isActual(const bool val);

  bool operator == (const TEvent & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(isActual == rhs.isActual))
      return false;
    return true;
  }
  bool operator != (const TEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEvent &a, TEvent &b);

inline std::ostream& operator<<(std::ostream& out, const TEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TResponse__isset {
  _TResponse__isset() : status(false), executeEvents(false), modifiedEvent(false), comment(false) {}
  bool status :1;
  bool executeEvents :1;
  bool modifiedEvent :1;
  bool comment :1;
} _TResponse__isset;

class TResponse {
 public:

  TResponse(const TResponse&);
  TResponse& operator=(const TResponse&);
  TResponse() : status((TStatus::type)0), comment() {
  }

  virtual ~TResponse() throw();
  TStatus::type status;
  std::vector<TEvent>  executeEvents;
  TEvent modifiedEvent;
  std::string comment;

  _TResponse__isset __isset;

  void __set_status(const TStatus::type val);

  void __set_executeEvents(const std::vector<TEvent> & val);

  void __set_modifiedEvent(const TEvent& val);

  void __set_comment(const std::string& val);

  bool operator == (const TResponse & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.executeEvents != rhs.__isset.executeEvents)
      return false;
    else if (__isset.executeEvents && !(executeEvents == rhs.executeEvents))
      return false;
    if (__isset.modifiedEvent != rhs.__isset.modifiedEvent)
      return false;
    else if (__isset.modifiedEvent && !(modifiedEvent == rhs.modifiedEvent))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TResponse &a, TResponse &b);

inline std::ostream& operator<<(std::ostream& out, const TResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPxpSpec__isset {
  _TPxpSpec__isset() : ip(false), port(false), description(false), id(false) {}
  bool ip :1;
  bool port :1;
  bool description :1;
  bool id :1;
} _TPxpSpec__isset;

class TPxpSpec {
 public:

  TPxpSpec(const TPxpSpec&);
  TPxpSpec& operator=(const TPxpSpec&);
  TPxpSpec() : ip(), port(0), description(), id() {
  }

  virtual ~TPxpSpec() throw();
  std::string ip;
  tint port;
  std::string description;
  std::string id;

  _TPxpSpec__isset __isset;

  void __set_ip(const std::string& val);

  void __set_port(const tint val);

  void __set_description(const std::string& val);

  void __set_id(const std::string& val);

  bool operator == (const TPxpSpec & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TPxpSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPxpSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPxpSpec &a, TPxpSpec &b);

inline std::ostream& operator<<(std::ostream& out, const TPxpSpec& obj)
{
  obj.printTo(out);
  return out;
}


class TContainer {
 public:

  TContainer(const TContainer&);
  TContainer& operator=(const TContainer&);
  TContainer() : id() {
  }

  virtual ~TContainer() throw();
  std::string id;
  std::vector<TAttribute>  attributes;

  void __set_id(const std::string& val);

  void __set_attributes(const std::vector<TAttribute> & val);

  bool operator == (const TContainer & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const TContainer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TContainer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TContainer &a, TContainer &b);

inline std::ostream& operator<<(std::ostream& out, const TContainer& obj)
{
  obj.printTo(out);
  return out;
}


class TData {
 public:

  TData(const TData&);
  TData& operator=(const TData&);
  TData() : id() {
  }

  virtual ~TData() throw();
  std::string id;

  void __set_id(const std::string& val);

  bool operator == (const TData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TData &a, TData &b);

inline std::ostream& operator<<(std::ostream& out, const TData& obj)
{
  obj.printTo(out);
  return out;
}


class TName {
 public:

  TName(const TName&);
  TName& operator=(const TName&);
  TName() : name() {
  }

  virtual ~TName() throw();
  std::string name;

  void __set_name(const std::string& val);

  bool operator == (const TName & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const TName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TName &a, TName &b);

inline std::ostream& operator<<(std::ostream& out, const TName& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TXmlPolicy__isset {
  _TXmlPolicy__isset() : description(false), templateId(false), templateXml(false), dataClass(false) {}
  bool description :1;
  bool templateId :1;
  bool templateXml :1;
  bool dataClass :1;
} _TXmlPolicy__isset;

class TXmlPolicy {
 public:

  TXmlPolicy(const TXmlPolicy&);
  TXmlPolicy& operator=(const TXmlPolicy&);
  TXmlPolicy() : name(), xml(), description(), templateId(), templateXml(), dataClass() {
  }

  virtual ~TXmlPolicy() throw();
  std::string name;
  std::string xml;
  std::string description;
  std::string templateId;
  std::string templateXml;
  std::string dataClass;

  _TXmlPolicy__isset __isset;

  void __set_name(const std::string& val);

  void __set_xml(const std::string& val);

  void __set_description(const std::string& val);

  void __set_templateId(const std::string& val);

  void __set_templateXml(const std::string& val);

  void __set_dataClass(const std::string& val);

  bool operator == (const TXmlPolicy & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(xml == rhs.xml))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(templateId == rhs.templateId))
      return false;
    if (!(templateXml == rhs.templateXml))
      return false;
    if (!(dataClass == rhs.dataClass))
      return false;
    return true;
  }
  bool operator != (const TXmlPolicy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TXmlPolicy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TXmlPolicy &a, TXmlPolicy &b);

inline std::ostream& operator<<(std::ostream& out, const TXmlPolicy& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TPtpResponse__isset {
  _TPtpResponse__isset() : policy(false), status(false), message(false) {}
  bool policy :1;
  bool status :1;
  bool message :1;
} _TPtpResponse__isset;

class TPtpResponse {
 public:

  TPtpResponse(const TPtpResponse&);
  TPtpResponse& operator=(const TPtpResponse&);
  TPtpResponse() : status((TStatus::type)0), message() {
  }

  virtual ~TPtpResponse() throw();
  TXmlPolicy policy;
  TStatus::type status;
  std::string message;

  _TPtpResponse__isset __isset;

  void __set_policy(const TXmlPolicy& val);

  void __set_status(const TStatus::type val);

  void __set_message(const std::string& val);

  bool operator == (const TPtpResponse & rhs) const
  {
    if (!(policy == rhs.policy))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const TPtpResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPtpResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPtpResponse &a, TPtpResponse &b);

inline std::ostream& operator<<(std::ostream& out, const TPtpResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TobiasEvent__isset {
  _TobiasEvent__isset() : name(false), parameters(false) {}
  bool name :1;
  bool parameters :1;
} _TobiasEvent__isset;

class TobiasEvent {
 public:

  TobiasEvent(const TobiasEvent&);
  TobiasEvent& operator=(const TobiasEvent&);
  TobiasEvent() : name() {
  }

  virtual ~TobiasEvent() throw();
  std::string name;
  std::map<std::string, std::string>  parameters;

  _TobiasEvent__isset __isset;

  void __set_name(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  bool operator == (const TobiasEvent & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    return true;
  }
  bool operator != (const TobiasEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TobiasEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TobiasEvent &a, TobiasEvent &b);

inline std::ostream& operator<<(std::ostream& out, const TobiasEvent& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TobiasResponse__isset {
  _TobiasResponse__isset() : status(false), executeEvents(false), modifiedEvents(false) {}
  bool status :1;
  bool executeEvents :1;
  bool modifiedEvents :1;
} _TobiasResponse__isset;

class TobiasResponse {
 public:

  TobiasResponse(const TobiasResponse&);
  TobiasResponse& operator=(const TobiasResponse&);
  TobiasResponse() : status((TobiasStatusType::type)0) {
  }

  virtual ~TobiasResponse() throw();
  TobiasStatusType::type status;
  std::vector<TobiasEvent>  executeEvents;
  TobiasEvent modifiedEvents;

  _TobiasResponse__isset __isset;

  void __set_status(const TobiasStatusType::type val);

  void __set_executeEvents(const std::vector<TobiasEvent> & val);

  void __set_modifiedEvents(const TobiasEvent& val);

  bool operator == (const TobiasResponse & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.executeEvents != rhs.__isset.executeEvents)
      return false;
    else if (__isset.executeEvents && !(executeEvents == rhs.executeEvents))
      return false;
    if (__isset.modifiedEvents != rhs.__isset.modifiedEvents)
      return false;
    else if (__isset.modifiedEvents && !(modifiedEvents == rhs.modifiedEvents))
      return false;
    return true;
  }
  bool operator != (const TobiasResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TobiasResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TobiasResponse &a, TobiasResponse &b);

inline std::ostream& operator<<(std::ostream& out, const TobiasResponse& obj)
{
  obj.printTo(out);
  return out;
}

}}}}}}} // namespace

#endif
