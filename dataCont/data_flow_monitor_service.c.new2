#include "data_flow_monitor_service.h"
#include <pthread.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>


dataCont_ptr dataCont;
PblMap *mapConnections;
/*
// XML-RPC functions
void data_flow_monitor_handler (__attribute__((unused)) SoupServer *server,
								SoupMessage *msg,
								__attribute__((unused)) const char *path,
								__attribute__((unused)) GHashTable *query,
								__attribute__((unused)) SoupClientContext *context,
								__attribute__((unused)) gpointer data) {
	char *method_name;
	GValueArray *params;


	if (!msg_post(msg)) return;

	soup_message_set_status (msg, SOUP_STATUS_OK);

	if (!parse_method_call(msg, &method_name, &params)) return;

	// =====>>>>> lock semaphore
	sem_wait(&dataCont->lock);

	if (!strcmp (method_name, DFMS_CALL_ACCEPT)) {
		service_handler_accept(msg, params);
	} else if (!strcmp (method_name, DFMS_CALL_DATAFORSINK)) {
		service_handler_dataForSink(msg, params);
	} else if (!strcmp (method_name, DFMS_CALL_SHUTDOWN)) {
		service_handler_shutdown(msg, params);
	} else if (!strcmp (method_name, DFMS_CALL_INSERTMECHANISM)) {
		service_handler_insertMechanism(msg, params);
	} else {
		soup_xmlrpc_set_fault (msg, SOUP_XMLRPC_FAULT_SERVER_ERROR_REQUESTED_METHOD_NOT_FOUND, "Unknown method %s", method_name);
	}
	dataCont_print(dataCont, 2);

	// <<<<<===== release semaphore
	sem_post(&dataCont->lock);

	g_free (method_name);
	g_value_array_free (params);
}
*/


/**
 * Initializes the service that waits for remote connections
 * to get information from the local data flow monitor
 */
void data_flow_monitor_service(dataCont_ptr dc) {
	dataCont = dc;

	printf("data_flow_monitor_service starting\n");

	mapConnections = pblMapNewHashMap();
	if (mapConnections == NULL) {
		plog(LOG_ERROR, "Error initializing hash table.");
		return;
	}

	pthread_t wait_thread;
	pthread_create(&wait_thread, NULL, (void *) wait_for_remote_pips, NULL);

	printf("data_flow_monitor_service returning\n");

	// now, terminate this thread that was supposed to start setup of data flow monitor service
}




void *wait_for_remote_pips(__attribute__((unused)) void *arg) {
	// we wait for new PIPs to connect
	// by waiting on port DFMS_PORT

	int mysock;
	struct sockaddr_in myaddr;
	struct sockaddr client;
	socklen_t client_len;

	printf("Waiting for PIPs to connect.\n");

	if ((mysock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		plog(LOG_FATAL,"Cannot create PIP socket.");
		exit(1);
	}


	bzero((char*) &myaddr,sizeof(myaddr));
	myaddr.sin_family = AF_INET;
	myaddr.sin_addr.s_addr = INADDR_ANY;
	myaddr.sin_port = htons(DFMS_PORT);

	if (bind(mysock,(struct sockaddr*) &myaddr, sizeof(myaddr)) < 0) {
		plog(LOG_FATAL,"Cannot bind PIP.");
		exit(1);
	}

	if (listen(mysock, 1) == -1) {
		plog(LOG_FATAL,"PIP cannot listen.");
		exit(1);
	}

	while(1) {
		int *clsock = calloc(1, sizeof(int));

		if (((*clsock = accept(mysock,&client,&client_len)) < 0)) {
			free(clsock);
		}

		// if a PIP connects:
		// we create a thread for each connected PIP
		printf("a new PIP connected.\n");
		pthread_t con_thread;
		pthread_create(&con_thread, NULL, (void*) new_remote_pip_thread, clsock);

	}

	return NULL;
}



void new_remote_pip_thread(void *arg) {
	int *sock = (int*) arg;

	printf("new_remote_pip_thread starting\n");

	char *remote_ip = calloc(IP_LEN_HEX+1, sizeof(char*));

	printf("new_remote_pip_thread before reading\n");
	int tmpread = 0;
	int totalread = 0;
	while (totalread < IP_LEN_HEX) {
		if ((tmpread = read(*sock, remote_ip+tmpread, IP_LEN_HEX-tmpread)) != -1) {
			totalread += tmpread;
		}
	}
	printf("read: %s\n",remote_ip);
	printf("new_remote_pip_thread after reading\n");

	if (!pblMapContainsKey(mapConnections,remote_ip,strlen(remote_ip))) {
		printf("new_remote_pip_thread does not contain\n");
		// add mapping to socket
		pblMapAdd(mapConnections, remote_ip, strlen(remote_ip), sock, sizeof(int));

		wait_message(sock);
	}
}






void service_handler_accept_req(int *socket, char *readBuf) {
	printf("service_handler_accept starting\n");

	char local_socket_name[ADDRxADDR_STR_LEN];
	char remote_socket_name[ADDRxADDR_STR_LEN];

	char *local_cont_id = NULL;
	char remote_cont_id[CONT_ID_LEN];

	char local_ip[IP_LEN_HEX+1];
	char local_port[PORT_LEN+1];
	char remote_ip[IP_LEN_HEX+1];
	char remote_port[PORT_LEN+1];


	bzero(local_socket_name, ADDRxADDR_STR_LEN);
	bzero(remote_socket_name, ADDRxADDR_STR_LEN);
	bzero(remote_cont_id, CONT_ID_LEN);
	bzero(local_ip, IP_LEN_HEX+1);
	bzero(local_port, PORT_LEN+1);
	bzero(remote_ip, IP_LEN_HEX+1);
	bzero(remote_port, PORT_LEN+1);

	sscanf(readBuf,"DFMS_ACCEPT_REQ %s %s %s %s %s",
					remote_ip, remote_port, local_ip, local_port, remote_cont_id);

	printf("read: %s, %s, %s, %s, %s\n",remote_ip, remote_port, local_ip, local_port, remote_cont_id 	);

	toADDRxADDR(local_socket_name,ADDRxADDR_STR_LEN,local_ip,local_port,remote_ip,remote_port);
	toADDRxADDR(remote_socket_name,ADDRxADDR_STR_LEN,remote_ip,remote_port,local_ip,local_port);


	printf("service_handler_accept before while\n");

	// get local container id
//	while (local_cont_id == NULL) {
		local_cont_id = dataCont_getNaming(dataCont, GLOBAL_ADDR, local_socket_name);

//		sem_post(&dataCont->lock);
//		usleep(33);					// wait for local connect()
//		sem_wait(&dataCont->lock);
//	}

	printf("service_handler_accept after while\n");

	// add name for remote container
	dataCont_addNaming(dataCont, GLOBAL_ADDR, remote_socket_name, remote_cont_id);

	// add alias from local container to remote container
	dataCont_addAlias(dataCont, local_cont_id, remote_cont_id);



	printf("service_handler_accept before writing\n");
	int tmpwritten = 0;
	int totalwritten = 0;
	while (totalwritten < CONT_ID_LEN) {
		if ((tmpwritten = write(*socket,local_cont_id+tmpwritten,CONT_ID_LEN-tmpwritten)) != -1) {
			totalwritten += tmpwritten;
		}
		else {
			perror("write");
		}
	}
	printf("service_handler_accept after writing\n");
}




/*
void service_handler_accept(SoupMessage *msg, GValueArray *params) {
	char local_socket_name[ADDRxADDR_STR_LEN];
	char remote_socket_name[ADDRxADDR_STR_LEN];

	char *local_cont_id = NULL;
	char *remote_cont_id = NULL;

	char *remote_ip;
	char *remote_port;
	char *local_ip;
	char *local_port;

	if (!soup_value_array_get_nth (params, 0, G_TYPE_STRING, &remote_ip)) {
		type_error (msg, G_TYPE_STRING, params, 0);
		return;
	}

	if (!soup_value_array_get_nth (params, 1, G_TYPE_STRING, &remote_port)) {
		type_error (msg, G_TYPE_STRING, params,1);
		return;
	}

	if (!soup_value_array_get_nth (params, 2, G_TYPE_STRING, &local_ip)) {
		type_error (msg, G_TYPE_STRING, params, 2);
		return;
	}

	if (!soup_value_array_get_nth (params, 3, G_TYPE_STRING, &local_port)) {
		type_error (msg, G_TYPE_STRING, params, 3);
		return;
	}

	if (!soup_value_array_get_nth (params, 4, G_TYPE_STRING, &remote_cont_id)) {
		type_error (msg, G_TYPE_STRING, params, 4);
		return;
	}

	toADDRxADDR(local_socket_name,ADDRxADDR_STR_LEN,local_ip,local_port,remote_ip,remote_port);

	toADDRxADDR(remote_socket_name,ADDRxADDR_STR_LEN,remote_ip,remote_port,local_ip,local_port);


//	printf("++ accept():\n");fflush(NULL);
//	printf("++ [remote ip:port = %s:%s]\n",remote_ip,remote_port);fflush(NULL);
//	printf("++ [remote cont id = %s]\n", remote_cont_id);fflush(NULL);
//	printf("++ [local socket name = %s]\n",local_socket_name);fflush(NULL);


	// get local container id
	while (local_cont_id == NULL) {
		local_cont_id = dataCont_getNaming(dataCont, GLOBAL_ADDR, local_socket_name);

		sem_post(&dataCont->lock);
		usleep(33);					// wait for local connect()
		sem_wait(&dataCont->lock);
	}

	// add name for remote container
	dataCont_addNaming(dataCont, GLOBAL_ADDR, remote_socket_name, remote_cont_id);

	// add alias from local container to remote container
	dataCont_addAlias(dataCont, local_cont_id, remote_cont_id);

	// return the local container id
	soup_xmlrpc_set_response (msg, G_TYPE_STRING, local_cont_id);
}
*/


char *service_caller_accept(char *remote_ip, char *remote_port, char *local_ip, char *local_port, char *local_cont_id) {
	printf("service_caller_accept starting\n");

	size_t size;
	int *my_socket;

	if (pblMapContainsKey(mapConnections,remote_ip,strlen(remote_ip))) {
		printf("remote PIP found.\n");
		my_socket = (int*) pblMapGet(mapConnections,remote_ip,strlen(remote_ip),&size);
	}
	else {
		printf("remote PIP not found. connecting.\n");
		my_socket = calloc(1, sizeof(int));

		struct sockaddr_in client;
		char ip[CANONICAL_IP_LEN+1];

		if ((*my_socket = socket(AF_INET,SOCK_STREAM,0)) == 0) {
			plog(LOG_FATAL,"Cannot create PIP socket.");
			exit(1);
		}

		bzero((char*) &client,sizeof(struct sockaddr_in));
		client.sin_family = AF_INET;
		client.sin_addr.s_addr = inet_addr(getCanonicalIP((char*) ip,CANONICAL_IP_LEN+1,remote_ip));
		client.sin_port = htons(DFMS_PORT);

		if (connect(*my_socket, (struct sockaddr*) &client, sizeof(struct sockaddr_in)) < 0) {
			plog(LOG_FATAL,"Cannot connect to remote PIP.");
			exit(1);
		}

		// map
		pblMapAdd(mapConnections, remote_ip, strlen(remote_ip), my_socket, sizeof(int));

		// send initial message
		int tmpwritten = 0;
		int totalwritten = 0;
		while (totalwritten < IP_LEN_HEX) {
			if ((tmpwritten = write(*my_socket,local_ip+tmpwritten,IP_LEN_HEX-tmpwritten)) != -1) {
				totalwritten += tmpwritten;
			}
		}
	}


	// prepare the message
	char message[4096];
	bzero(message, 4096);
	snprintf(message,4096,"DFMS_ACCEPT_REQ %s %s %s %s %s",
			local_ip,local_port,remote_ip,remote_port,local_cont_id);


	printf("service_caller_accept before sending\n");

	// send it
	int tmpwritten = 0;
	int totalwritten = 0;
	while (totalwritten < 4096) {
		if ((tmpwritten = write(*my_socket,message+tmpwritten,4096-tmpwritten)) != -1) {
			totalwritten += tmpwritten;
		}
	}

	printf("service_caller_accept after sending\n");

	char *remote_cont_id = (char *) calloc (CONT_ID_LEN+1, sizeof(char));

	printf("service_caller_accept before reading\n");
	int tmpread = 0;
	int totalread = 0;
	while (totalread < CONT_ID_LEN) {
		if ((tmpread = read(*my_socket, remote_cont_id+tmpread, CONT_ID_LEN-tmpread)) != -1) {
			totalread += tmpread;
		}
	}
	printf("service_caller_accept after reading\n");

	return remote_cont_id;
}


void *wait_message(void *arg) {

	printf("wait_message starting\n");fflush(NULL);

	int *socket = (int *) arg;

	printf("wait_message socket %d\n",*socket);fflush(NULL);

	while (1) {

		char readBuf[4096];
		bzero(readBuf, 4096);

		printf("wait_message before read\n");fflush(NULL);

		int tmpread = 0;
		int totalread = 0;
		while (totalread < 4096) {
			if ((tmpread = read(*socket, readBuf+tmpread, 4096-tmpread)) != -1) {
				totalread += tmpread;
			}
		}

		printf("wait_message after read\n");fflush(NULL);

		if (strstr(readBuf,"DFMS_ACCEPT_REQ") == readBuf) {
			service_handler_accept_req(socket, readBuf);
		}
		else if (strstr(readBuf,"DFMS_SHUTDOWN") == readBuf) {
			service_handler_shutdown(readBuf);
		}
	}

	printf("wait_message returning\n");fflush(NULL);

	return NULL;
}



/*
void service_handler_dataForSink(SoupMessage *msg, GValueArray *params) {
	GValueArray *g_lod;
	GValueArray *g_mechanisms_per_data;
	GValueArray *g_mechanisms;

	int *mechanisms_per_data;
	char *cont;
	char *val;
	char **mechanisms;
	unsigned int i, j;



	if (!soup_value_array_get_nth (params, 0, G_TYPE_VALUE_ARRAY, &g_lod)) {
		type_error (msg, G_TYPE_VALUE_ARRAY, params, 0);
		exit(1);
	}

	if (!soup_value_array_get_nth (params, 1, G_TYPE_VALUE_ARRAY, &g_mechanisms_per_data)) {
		type_error (msg, G_TYPE_VALUE_ARRAY, params, 1);
		exit(1);
	}

	if (!soup_value_array_get_nth (params, 2, G_TYPE_VALUE_ARRAY, &g_mechanisms)) {
		type_error (msg, G_TYPE_VALUE_ARRAY, params, 2);
		exit(1);
	}

	if (!soup_value_array_get_nth (params, 3, G_TYPE_STRING, &cont)) {
		type_error (msg, G_TYPE_STRING, params, 3);
		exit(1);
	}


	for (i = 0; i < g_lod->n_values; i++) {
		if (!soup_value_array_get_nth (g_lod, i, G_TYPE_STRING, &val)) {
			type_error (msg, G_TYPE_STRING, params, i);
			exit(1);
		}

		// add all the data to the corresponding container
		dataCont_addDataCont_noUpdate(dataCont, val, cont);
	}


	// get the array with the number of mechanisms per data
	mechanisms_per_data = malloc(g_mechanisms_per_data->n_values * sizeof(int));
	for (i = 0; i < g_mechanisms_per_data->n_values; i++) {
		if (!soup_value_array_get_nth (g_mechanisms_per_data, i, G_TYPE_INT, &mechanisms_per_data[i])) {
			type_error (msg, G_TYPE_INT, params, i);
			exit(1);
		}
	}


	mechanisms = malloc(g_mechanisms->n_values * sizeof(char*));
	for (i = 0; i < g_mechanisms->n_values; i++) {
		if (!soup_value_array_get_nth (g_mechanisms, i, G_TYPE_STRING, &mechanisms[i])) {
			type_error (msg, G_TYPE_STRING, params, i);
			exit(1);
		}

//		for (j = 0; j < g_lod->n_values; j++) {
//			str_replace_all(mechanisms[i], old_data_ids[j], new_data_ids[j]);
//		}
	}



	// TODO: loop over all mechanisms and add all of them


	if (g_mechanisms->n_values > 0) {
//		printf("====================\n");fflush(NULL);
//		printf("%s\n",mechanisms[0]);fflush(NULL);
//		printf("====================\n");fflush(NULL);

		xmlDocPtr d = xmlRecoverMemory(mechanisms[0], strlen(mechanisms[0]));
		xmlNodePtr rootNode = xmlDocGetRootElement(d);
//		printf("parse and add: %d",parse_and_add_mechanism(rootNode));fflush(NULL);
	}


	soup_xmlrpc_set_response (msg, G_TYPE_INT, 0);
}
*/

/*
void service_caller_dataForSink(char *remote_ip, list_of_data_ptr lod, unsigned int lod_len, char *cont, int *mechanisms_per_data, unsigned char **mechanisms) {

	SoupSession *session;
	GValue g_return_value;
	GValueArray *g_lod;
	GValueArray *g_mechanisms;
	GValueArray *g_mechanisms_per_data;



	int result;
	char ip[CANONICAL_IP_LEN+1];
	char service_uri[DFMS_SERVICE_URI_LEN];
	unsigned int i;
	unsigned int nr_of_mechanisms;
	list_of_data_ptr tmplod;


	// assemble list of data as array for SOUP
	g_lod = g_value_array_new(lod_len);
	for (tmplod = lod; tmplod; tmplod = tmplod->next) {
		soup_value_array_append(g_lod, G_TYPE_STRING, tmplod->data->data_ID);
	}


	// assemble mechanisms per data as array
	g_mechanisms_per_data = g_value_array_new(lod_len);
	nr_of_mechanisms = 0;
	for (i = 0; i < lod_len; i++) {
		nr_of_mechanisms += mechanisms_per_data[i];
		soup_value_array_append(g_mechanisms_per_data, G_TYPE_INT, mechanisms_per_data[i]);
	}


	// assemble mechanisms as array
	g_mechanisms = g_value_array_new(nr_of_mechanisms);
	for (i = 0; i < nr_of_mechanisms; i++) {
		soup_value_array_append(g_mechanisms, G_TYPE_STRING, mechanisms[i]);
	}



	session = soup_session_sync_new();

	snprintf(service_uri,DFMS_SERVICE_URI_LEN,"http://%s:%d%s",getCanonicalIP(ip,CANONICAL_IP_LEN+1,remote_ip),DFMS_PORT,DFMS_NAME);

	sem_post(&dataCont->lock);
	if (!do_xmlrpc (session, service_uri, DFMS_CALL_DATAFORSINK, &g_return_value,
					G_TYPE_VALUE_ARRAY, g_lod,
					G_TYPE_VALUE_ARRAY, g_mechanisms_per_data,
					G_TYPE_VALUE_ARRAY, g_mechanisms,
					G_TYPE_STRING, cont,
					G_TYPE_INVALID)) {
		plog(LOG_INFO, "Not available: %s",service_uri);
		g_value_array_free(g_lod);
		g_value_array_free(g_mechanisms);
		g_value_array_free(g_mechanisms_per_data);
		exit(1);
	}

	plog(LOG_TRACE, "Checking response");
	if (!check_xmlrpc (&g_return_value, G_TYPE_INT, &result)) {
		plog(LOG_ERROR, "Protocol error in response.");
		g_value_array_free(g_lod);
		exit(1);
	}
	sem_wait(&dataCont->lock);

	g_value_array_free(g_lod);

	soup_session_abort(session);

}
*/





void service_handler_shutdown(char *msg) {
	printf("service_handler_shutdown starting\n");
	char *cont_id;
	char name[CONT_ID_LEN];
	char how[SHUT_MAXLEN];
	int i;
	int size;
	char ***names;

	bzero(name, CONT_ID_LEN);
	bzero(how, SHUT_MAXLEN);


	// read SHUTDOWN message
	sscanf(msg,"DFMS_SHUTDOWN %s %s", name, how);

	printf("service_handler_shutdown after scanf\n");

	// get the socket container: f((pid,sfd))
	cont_id = dataCont_getNaming(dataCont, GLOBAL_ADDR, name);

	// all names of container
	names = dataCont_getAllNamingsOfContainer(dataCont, cont_id, &size);

	printf("service_handler_shutdown 1\n");

	if (!strcmp(how,SHUT_RD_STR) || !strcmp(how,SHUT_RDWR_STR)) {
		// disallow reception

		// empty storage function
		dataCont_emptyCont(dataCont,cont_id);

		// delete all aliases to container
		dataCont_delAllAliasesTo(dataCont, cont_id);
	}

	printf("service_handler_shutdown 2\n");

	if (!strcmp(how,SHUT_WR_STR) || !strcmp(how,SHUT_RDWR_STR)) {
		// disallow transmission

		// delete all aliases from this container
		dataCont_delAllAliasesFrom(dataCont, cont_id);
	}

	printf("service_handler_shutdown 3\n");

	if (!strcmp(how,SHUT_RDWR_STR)) {
		// disallow transmission and reception;
		// therefore delete all identifiers of type ADDR

		// delete all identifiers of type ADDR
		if (names != NULL) {
			for (i = 0; i < size; i++) {
				if (is_ADDR(names[i][0]) == 0) {
					dataCont_delNaming(dataCont, names[i][0], names[i][1]);
				}
				free(names[i][0]);
				free(names[i][1]);
				free(names[i]);
			}
			free(names);
		}
	}

	printf("service_handler_shutdown 4\n");

	free(cont_id);
	printf("service_handler_shutdown returning\n");
}


void service_caller_shutdown(char *remote_ip, char *name, char *how) {
	printf("service_caller_shutdown starting\n");fflush(NULL);
	size_t size;
	printf("service_caller_shutdown remote ip %s\n",remote_ip);fflush(NULL);

	int mysocket = *((int*) pblMapGet(mapConnections,remote_ip,strlen(remote_ip),&size));

	printf("service_caller_shutdown socket: %d\n",mysocket);fflush(NULL);

	// prepare the message
	char message[4096];
	bzero(message, 4096);
	snprintf(message,4096,"DFMS_SHUTDOWN %s %s",name,how);

	// send it
	int tmpwritten = 0;
	int totalwritten = 0;
	while (totalwritten < 4096) {
		if ((tmpwritten = write(mysocket,message+tmpwritten,4096-tmpwritten)) != -1) {
			totalwritten += tmpwritten;
		}
		else {
			perror("write");
		}
	}
	printf("service_caller_shutdown returning\n");fflush(NULL);
}

/*
void service_caller_shutdown(char *remote_ip, char *name, char *how) {
	SoupSession *session;
	GValue g_return_value;
	char ip[CANONICAL_IP_LEN+1];
	char service_uri[DFMS_SERVICE_URI_LEN];
	int result;


	session = soup_session_sync_new();

	snprintf(service_uri,DFMS_SERVICE_URI_LEN,"http://%s:%d%s",getCanonicalIP(ip,CANONICAL_IP_LEN+1,remote_ip),DFMS_PORT,DFMS_NAME);

	sem_post(&dataCont->lock);
	if (!do_xmlrpc (session, service_uri, DFMS_CALL_SHUTDOWN, &g_return_value,
					G_TYPE_STRING, name,
					G_TYPE_STRING, how,
					G_TYPE_INVALID)) {
		plog(LOG_INFO, "Not available: %s",service_uri);
		exit(1);
	}


	plog(LOG_TRACE, "Checking response");
	if (!check_xmlrpc (&g_return_value, G_TYPE_INT, &result)) {
		plog(LOG_ERROR, "Protocol error in response.");
		exit(1);
	}
	sem_wait(&dataCont->lock);

	soup_session_abort(session);
}
*/




/*
void service_handler_insertMechanism(SoupMessage *msg, GValueArray *params) {
	char *mechanism;


	if (!soup_value_array_get_nth (params, 0, G_TYPE_STRING, &mechanism)) {
		type_error (msg, G_TYPE_STRING, params, 0);
		exit(1);
	}

	xmlDocPtr d = xmlRecoverMemory(mechanism, strlen(mechanism));
	xmlNodePtr rootNode = xmlDocGetRootElement(d);
	parse_and_add_mechanism(rootNode);


	soup_xmlrpc_set_response (msg, G_TYPE_INT, 0);
}
*/
