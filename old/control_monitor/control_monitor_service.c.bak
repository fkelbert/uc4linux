/*
 * Authors: Ricardo Neisse and Carolina Lorini.
 *
 */

/*
 * TODO:
 *
 *  - Check memory allocation in the parse functions, after
 *    a mechanism is added all the information is copied so
 *    we can free the memory allocated for parsing
 *    For events, mechanism actions, etc.
 *      free(event->params);
 *      free(event); *
 *
 *  - condition is 2048 bytes hard coded
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>

#include <libxml/parser.h>
#include <libxml/xmlversion.h>
#include <libxml/xmlmemory.h>
#include <libxml/debugXML.h>
#include <libxml/xmlschemas.h>
#include <libxml/xmlschemastypes.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>

#include "event.h"
#include "logger.h"
#include "str_utils.h"
#include "time_utils.h"
#include "hash_table.h"
#include "xml_utils.h"
#include "soup_utils.h"
#include "past_monitor.h"
#include "control_monitor.h"


int do_notify_event (SoupMessage *msg, GValueArray *params);

void control_monitor_service  (SoupServer *server, SoupMessage *msg, const char *path, GHashTable *query, SoupClientContext *context, gpointer data);

void control_monitor_service  (SoupServer *server, SoupMessage *msg, const char *path, GHashTable *query, SoupClientContext *context, gpointer data) {
  char *method_name;
  GValueArray *params;

  plog (LOG_INFO, "Acessing control_monitor_service");
  if (!msg_post(msg)) return;
  soup_message_set_status (msg, SOUP_STATUS_OK);
  if (!parse_method_call(msg, &method_name, &params)) return;

  if (!strcmp (method_name, "notify_event")) {
    plog (LOG_INFO, "Invoking notify_event()");
    do_notify_event (msg, params);
    // } else if (!strcmp (method_name, "direct_anonymous_attestation")) {
    //    log (LOG_INFO, "Invoking method direct_anonymous_attestation()");
    //    do_direct_anonymous_attestation (msg, params);
  } else {
    plog (LOG_TRACE, "Method control_monitor.%s() not implemented", method_name);
    soup_xmlrpc_set_fault (msg, SOUP_XMLRPC_FAULT_SERVER_ERROR_REQUESTED_METHOD_NOT_FOUND, "Unknown method %s", method_name);
  }
  g_free (method_name);
  g_value_array_free (params);
}


/**
 * Receives and event, updates the monitor, and verifies if policies are violated
 * If a violation happens it returns the action part of the mechanism
 */
int do_notify_event (SoupMessage *msg, GValueArray *params) {
  char *method_name = "notify_event()";
  // char *val, *tmp_s;

  GHashTable *g_event;
  event_t * event;
  char par_name[10], par_value[10], par_count[10];
  char *num_params;
  int i, k;


  GHashTable
  *g_action_allow,
  *g_action_modify,
  *g_action_delay,
  *g_action_inhibit,
  *g_action_execute[20];

  GValueArray *ret_params;

  mechanism_actions_t *r_actions;

  plog (LOG_TRACE, "Retrieving GHashTable arguments for method %s", method_name);
  if (!soup_value_array_get_nth (params, 0, G_TYPE_HASH_TABLE, &g_event)) {
    plog (LOG_ERROR, "Wrong parameter for method %s", method_name);
    type_error (msg, G_TYPE_HASH_TABLE, params, 0);
    return;
  }
  /*
  if (!soup_value_array_get_nth (params, 0, G_TYPE_STRING, &par)) {
    plog (LOG_ERROR, "Wrong parameter for method %s", method_name);
    type_error (msg, G_TYPE_STRING, params, 0);
    return;
  }
  printf("Received string [%s]", par);
   */
  // g_hash_table_foreach (g_event, (GHFunc) print_data, NULL);

  event = (event_t*)malloc(sizeof(event_t));
  soup_value_hash_lookup (g_event, "event_name", G_TYPE_STRING, &event->event_name);
  event->desired = TRUE;
  soup_value_hash_lookup (g_event, "par_count", G_TYPE_STRING, &num_params);
  event->n_params = atoi(num_params);
  plog(LOG_DEBUG, "Received event event_name=[%s] par_count=[%d]", event->event_name, event->n_params);
  event->params = (param_t*)malloc(sizeof(param_t) * event->n_params);
  for (i=0; i < event->n_params; i++) {
    par_name[0] = '\0';
    par_value[0] = '\0';
    sprintf(par_name, "name_%d", i);
    sprintf(par_value, "value_%d", i);
    soup_value_hash_lookup (g_event, par_name, G_TYPE_STRING, &event->params[i].param_name);
    soup_value_hash_lookup (g_event, par_value, G_TYPE_STRING, &event->params[i].param_value);
    plog(LOG_TRACE, "  [%s]=[%s]", event->params[i].param_name, event->params[i].param_value);
  }
  // XML doc is used for evaluation of the
  // monitor's conditions
  create_xml_doc(event);
  r_actions = new_event_request(event);

  ret_params = soup_value_array_new();
  int index=0;

  g_action_allow = soup_value_hash_new();
  g_action_delay = soup_value_hash_new();
  g_action_modify = soup_value_hash_new();
  g_action_inhibit = soup_value_hash_new();

  if(r_actions == NULL){
    plog(LOG_DEBUG, "- Event allowed because there is no triggered mechanism");
    soup_value_hash_insert (g_action_allow, "action_name", G_TYPE_STRING, "allow");
    soup_value_array_insert (ret_params, index++, G_TYPE_HASH_TABLE, g_action_allow);
  } else {
    plog(LOG_DEBUG, "- Mechanism triggered, processing actions");
    plog_actions(LOG_TRACE, r_actions);
    switch (r_actions->response) {
      case ALLOW:
        plog(LOG_TRACE, "  action=[ALLOW]");
        soup_value_hash_insert (g_action_allow, "action_name", G_TYPE_STRING, "allow");
        soup_value_array_insert (ret_params, index++, G_TYPE_HASH_TABLE, g_action_allow);

        if (r_actions->n_params > 0) {
          soup_value_hash_insert (g_action_modify, "action_name", G_TYPE_STRING, "modify");
          par_value[0] = '\0';
          sprintf(par_value, "%d", r_actions->n_params);
          soup_value_hash_insert (g_action_modify, "par_count", G_TYPE_STRING, par_value);
          plog(LOG_TRACE, "  action=[MODIFY]");
          for (i=0 ; i < r_actions->n_params; i++) {
            par_name[0] = '\0';
            par_value[0] = '\0';
            sprintf(par_name, "name_%d", i+1);
            sprintf(par_value, "value_%d", i+1);
            soup_value_hash_insert (g_action_modify, par_name, G_TYPE_STRING, r_actions->modify[i].param_name);
            soup_value_hash_insert (g_action_modify, par_value, G_TYPE_STRING, r_actions->modify[i].param_value);
          }
          soup_value_array_insert (ret_params, index++, G_TYPE_HASH_TABLE, g_action_modify);
        }

        if (r_actions->n_actions > 0) {
          // g_action_execute = (GHashTable *)malloc(sizeof(GHashTable *) * r_actions->n_actions);
          for (i=0 ; i < r_actions->n_actions; i++) {
            if (i>19) continue;
            g_action_execute[i] = soup_value_hash_new();
            soup_value_hash_insert (g_action_execute[i], "action_name", G_TYPE_STRING, "execute");
            soup_value_hash_insert (g_action_execute[i], "name", G_TYPE_STRING, r_actions->execute[i].id);
            // printf("%s \n", r_actions->execute[i].id);
            par_value[0] = '\0';
            sprintf(par_value, "%d", r_actions->execute[i].n_params);
            soup_value_hash_insert (g_action_execute[i], "par_count", G_TYPE_STRING, par_value);
            if (r_actions->execute[i].n_params > 0) {
              for (k=0; k< r_actions->execute[i].n_params; k++) {
                par_name[0] = '\0';
                par_value[0] = '\0';
                sprintf(par_name, "name_%d", k+1);
                sprintf(par_value, "value_%d", k+1);
                soup_value_hash_insert (g_action_execute[i], par_name, G_TYPE_STRING, r_actions->execute[i].params[k].param_name);
                soup_value_hash_insert (g_action_execute[i], par_value, G_TYPE_STRING, r_actions->execute[i].params[k].param_value);
                //printf("%s \n", r_actions->execute[i].params[k].param_name);
              }
            }
            soup_value_array_insert (ret_params, index++, G_TYPE_HASH_TABLE, g_action_execute[i]);
          }
        }


        break;

      case INHIBIT:
        plog(LOG_TRACE, "  action=[INHIBIT]");
        soup_value_hash_insert (g_action_inhibit, "action_name", G_TYPE_STRING, "inhibit");
        soup_value_array_insert (ret_params, index++, G_TYPE_HASH_TABLE, g_action_inhibit);
        break;
    }
    plog_actions(LOG_TRACE, r_actions);
  }

  soup_xmlrpc_set_response (msg, G_TYPE_VALUE_ARRAY, ret_params);

  g_hash_table_destroy (g_action_allow);
  g_hash_table_destroy (g_action_delay);
  g_hash_table_destroy (g_action_modify);
  g_hash_table_destroy (g_action_inhibit);
  if (r_actions!=NULL) {
    for (i=0 ; i < r_actions->n_actions; i++) {
      if (i>19) continue;
      g_hash_table_destroy (g_action_execute[i]);
    }
  }
  xmlFreeDoc(event->xml_doc);

}

static void parse (xmlNode * a_node) {
  xmlNode *cur_node = NULL;

  for (cur_node = a_node; cur_node; cur_node = cur_node->next) {
    // if (cur_node->type == XML_ELEMENT_NODE) {
    plog(LOG_TRACE, "node type: Element, name: %s [%s] (%d)", cur_node->name, cur_node->content, cur_node->type);
    //}
    printf("Calling children (%s) \n", cur_node->name);
    parse(cur_node->children);
  }
}

GMainLoop *loop;

int main(int argc, char **argv) {

  // Control Monitor Service (XML-RPC)
  SoupServer *server;
  SoupAuthDomain *domain;
  int port = 8090;

  // Mechanisms XML representation
  char *schemaFilename = "Master-EnfLang-FHG.xsd";
  char *mechanismsFilename = "mechanisms.xml";
  xmlSchemaPtr schema = NULL;
  xmlLineNumbersDefault(1);
  xmlNode *rootNode;
  xmlNode *node0;

  // Variables to instantiate a mechanism
  // id + ECA (event, condition, and actions)
  char *id;
  event_t *event;
  // max size of condition is 2048
  // this should be fixed later on
  char condition[2048] = "";
  mechanism_actions_t *actions;

  // Time step associated with mechanism and past monitors
  int64_t usec_timestep;

  // Update thread sleep
  int64_t thread_usleep;

  plog (LOG_INFO, "Running control monitor service");

  if(!init_control_monitor()){
    plog(LOG_ERROR, "Error initializing library");
    return 0;
  }

  // sleep thread in control monitor is 200 miliseconds
  thread_usleep = 200000;
  start_past_monitor_update_thread(thread_usleep);

  plog(LOG_TRACE, "Loading mechanisms.xml");
  xmlDocPtr doc = loadXmlDoc(mechanismsFilename, schemaFilename);
  rootNode = xmlDocGetRootElement(doc);

  // 2 seconds time step for all monitors
  usec_timestep = 2000000;

  // Iterate through all control mechanisms
  for (node0 = rootNode->children; node0; node0 = node0->next) {
    if (strcmp(node0->name, "controlMechanism")==0) {

      parseControlMechanism(node0, &id, &event, condition, &actions);

      if(add_mechanism(id, event, condition, actions, usec_timestep)!=R_ERROR) {
        activate_mechanism(id);
      } else {
        plog(LOG_DEBUG,"Error adding mechanism '%s' NOT added", id);
      }
    }
  }

  plog(LOG_DEBUG, "Starting HTTP XML-RPC server [%d]", port);

  init_glib();

  plog(LOG_TRACE, "Creating SoupServer");
  if (!(server = soup_server_new("port", port, NULL))) {
    plog(LOG_ERROR, "Unable to bind SoupServer to port %d", port);
    exit (1);
  }

  // log(LOG_TRACE, "Skipping authentication domain setup");

  plog(LOG_DEBUG, "Adding [control_monitor_service] handler [/control_monitor_service]");
  soup_server_add_handler (server, "/control_monitor_service", control_monitor_service, NULL, NULL);

  plog(LOG_TRACE, "Starting glib thread");
  soup_server_run (server);

  g_object_unref (domain);

  return(0);
}


/*
// Print out the complete XML tree
FILE *tmp_file = fopen("mechanisms.xml.tmp","w");
xml_dump(tmp_file, rootNode);
fclose(tmp_file);
tmp_file = fopen("mechanisms.xml.tmp","r");
char *buf;
while (buf = readline(tmp_file))) {
  printf("%s\n", buf);
}
fclose(tmp_file);

// condition = "repmax(3,Eall(open,{(file,/home/test2.txt)}))";
// condition = "always(not(Eall(write,{(file,/dev/lpt1)})))";
// condition = "within(10 ,Eall(delete))";
// mechanism is triggered with NULL event
if(add_mechanism("delete", NULL, condition, &actions)==R_SUCCESS) {
  plog(LOG_DEBUG,"Mechanism 'delete' created");
} else {
  plog(LOG_DEBUG,"Error creating mechanism");
}
activate_mechanism("delete");

getchar();

plog(LOG_DEBUG,"generate read event");
mechanism_actions_t* r_actions;

r_actions = new_event_request(NULL);
if(r_actions == NULL){
  plog(LOG_TRACE, "Event allowed because there is no triggered mechanism");
} else {
  plog(LOG_TRACE, "- Mechanism triggered, processing actions");
  plog_actions(r_actions);
}

id = "Block_Evil_Messages";
event = (event_t*)malloc(sizeof(event_t));
event->event_name = "message";
// event->desired = TRUE;
event->n_params = 1;
event->params = (param_t*)malloc(sizeof(param_t));
event->params->param_name = "source";
event->params->param_value = "evil";

r_actions = new_event_request(event);
if(r_actions == NULL){
  plog(LOG_TRACE, "Event allowed because there is no triggered mechanism");
} else {
  plog(LOG_TRACE, "- Mechanism triggered, processing actions");
  plog_actions(r_actions);
}

r_actions = new_event_request(event);
if(r_actions == NULL){
  plog(LOG_TRACE, "Event allowed because there is no triggered mechanism");
} else {
  plog(LOG_TRACE, "- Mechanism triggered, processing actions");
  plog_actions(r_actions);
}
 */
