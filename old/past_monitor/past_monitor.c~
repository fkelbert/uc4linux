/*
 * Authors: Ricardo Neisse and Carolina Lorini.
 *
 */

/*
 * TODO:
 *
 *  - Save states after each update to guarantee that if the
 *    monitor process is restarted we do not loose the states
 *
 *  - Automatically calculate the update thread sleep time to
 *    adapt to the different time steps and update thread load
 *
 *  - Circular array that keep past states of some operators is
 *    a char array and each char hods a bit of information, this
 *    should be optimized to a bit size to save memory
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>

#include "event.h"
#include "past_monitor.h"
#include "past_parser.tab.h"
#include "hash_table.h"

#include "logger.h"
#include "data_flow_monitor.h"

data_flow_monitor_ptr data_flow_monitor;

// Hash table of existing monitors
// - (char *id, *t_monitor)
table_t *past_monitor_table;

// Update thread synchronization mutex
pthread_mutex_t past_monitor_mtx;


void IF_reset(){
	plog(LOG_DEBUG, "Initializing IF tracking");
	data_flow_monitor = data_flow_monitor_new();
	data_flow_monitor_init(data_flow_monitor);
	dataCont_print(data_flow_monitor->map, -1);
	plog(LOG_DEBUG, "IF tracking initialized");
}

int IF_update(event_t* event){
	data_flow_monitor_update(data_flow_monitor, event);
	return 0;
}

char* IF_initCont(char* cont){
	list_of_data_ptr lod;
	char* tmpdata;
	char* tmpcont;
	char PID[20];

	if (cont==NULL) return NULL;

	snprintf(PID, 20, "[%s x  FNAME]",data_flow_monitor->map->ip);

	tmpcont=dataCont_getNaming(data_flow_monitor->map, PID, cont);
	if (tmpcont==NULL) {
		tmpcont=dataCont_getNewContIDFile(data_flow_monitor->map);
		tmpdata=dataCont_getNewDataID(data_flow_monitor->map);
		dataCont_addDataCont(data_flow_monitor->map, tmpdata, tmpcont);
		dataCont_addNaming(data_flow_monitor->map, PID, cont, tmpcont);
	} else {
		lod=(dataCont_getDataIn(data_flow_monitor->map, tmpcont));
		tmpdata=strdup(lod->data->data_ID);
		//list_of_data_free(lod);
	}

	plog (LOG_INFO, " * %s -----> %s", cont, tmpdata);
	return tmpdata;
}

int A_is_refinement_of_B (event_t* A, event_t* B) {
	int k, j, c;
	c=0;
	char *tmpa, *tmpb;
	char *tmpcont;
	char PID[20];
	list_of_data_ptr lod;
	if (strcmp(A->event_name, B->event_name)!=0) return FALSE;

	snprintf(PID, 20, "[%s x  FNAME]",data_flow_monitor->map->ip);

	if (A->n_params >= B->n_params ) {
		for(k = 0; k < B->n_params; k++){
			for(j = 0; j < A->n_params; j++){
				plog(LOG_DEBUG, "  A[%d] B[%d]    A-[%s][%s]=[%s]  B-[%s][%s]=[%s] c=%d", j, k, A->event_name,A->params[j].param_name,A->params[j].param_value, B->event_name,B->params[k].param_name,B->params[k].param_value,c);
//				plog(LOG_INFO, "----------EXTRA : pval=%s and names.equals=%s", B->params[k].param_type, (strcmp(A->params[j].param_name, B->params[k].param_name) == 0)?"true":"false");

				if (strcmp(A->params[j].param_name, B->params[k].param_name) == 0) {
					//if(strcmp(A->params[j].param_name, "filename")!=0){
					if ((B->params[k].param_type == NULL) || (strcmp(B->params[k].param_type, "contUsage")==0)) {
						if (strcmp(A->params[j].param_value, B->params[k].param_value) == 0) {
							plog(LOG_INFO, "  [%s] matches [%s]", A->params[j].param_value, B->params[k].param_value);
							c++;
						} else {
							plog(LOG_INFO, "  [%s] doesn't match [%s]", A->params[j].param_value, B->params[k].param_value);
							break;
						}
					} else { //b->params[j].param_type=="dataUsage"

						if ((A->params[j].param_value==NULL)||(B->params[k].param_value==NULL)) break;

						tmpa=strdup(A->params[j].param_value);
						tmpb=strdup(B->params[k].param_value);
						//Let's check if data stored in file A is B

						tmpcont=dataCont_getNaming(data_flow_monitor->map,PID, tmpa);
						if (tmpcont==NULL) break; //no naming for A -> no data in the file

						lod=dataCont_getDataIn(data_flow_monitor->map, tmpcont);


						if (list_of_data_length(lod)==0) break; // no data in file A

						if (list_of_data_find(lod, tmpb)==0) {
							plog(LOG_INFO, "  [%s] \"refines\" [%s]", tmpa, tmpb);
							c++;
						}else {
							plog(LOG_INFO, "  [%s] doesn't \"refine\" [%s]", tmpa, tmpb);
							break;
						}
					}
				}
			}
		}
	}

	plog(LOG_INFO, "    B->n_params=%d c=%d", B->n_params, c);
	if (c==B->n_params) {
		plog(LOG_INFO, "    Event [%s] is a refinement of [%s]", A->event_name, B->event_name);
		return TRUE;
	}
	plog(LOG_INFO, "    Event [%s] is NOT refinement of [%s]", A->event_name, B->event_name);
	return FALSE;
}





void reset_monitor_table() {
	init_table(&past_monitor_table, 20);
}

int init_past_monitors() {
	plog(LOG_DEBUG, "Initializing IF tracking");

	data_flow_monitor = data_flow_monitor_new();
	data_flow_monitor_init(data_flow_monitor);
	dataCont_print(data_flow_monitor->map, -1);
	plog(LOG_DEBUG, "IF tracking initialized");

	plog(LOG_DEBUG, "Initializing past monitors");

	// Create a mutex that is used to synchronize the
	// update thread when new events arrive.
	pthread_mutex_init(&past_monitor_mtx, NULL);

	// Initializes data structures and creates
	// an empty hash table with size 20
	if(init_table(&past_monitor_table, 20)) {
		plog(LOG_ERROR, "Unable to create past monitors hash table");
		return R_ERROR;
	}

	plog(LOG_TRACE, "Past monitors initialized");
	return R_SUCCESS;
}

void start_past_monitor_update_thread(int64_t thread_usleep) {
	pthread_t update_thread;
	pthread_create(&update_thread, NULL,(void *)past_monitor_update_thread, &thread_usleep);
}

void past_monitor_update_thread(int64_t *thread_usleep) {
	// Generates periodically a NULL event to progress time step
	int64_t t_usleep = *thread_usleep;

	plog(LOG_DEBUG, "Starting past monitor update thread usleep=[%d]", t_usleep);

	while(1) {

		// plog(LOG_TRACE, "Update thread");
		update_all_past_monitors(NULL);

		// TODO: the sleep should be optimized considering
		// the average time it takes to update the monitors
		// and the time step specified. This is now manually
		// set to 5% of the timestep
		usleep(t_usleep);
	}
}

int add_past_monitor(char *id, char *formula, int64_t usec_timestep) {
	monitor_t *p_monitor;
	entry_t *new_entry;
	int n, i;
	int memcount;

	// Checks if id is available
	new_entry = lookup(&past_monitor_table, id);

	// Monitor not found in hash table, creating new
	if(!new_entry){
		plog (LOG_DEBUG, "- Creating new past monitor");
		plog (LOG_DEBUG, "  id=[%s] ", id);
		plog (LOG_DEBUG, "  formula=[%s]", formula);
		plog (LOG_DEBUG, "  timestep=[%d usec]", usec_timestep);

		p_monitor = (monitor_t *)malloc(sizeof(monitor_t));

		plog (LOG_TRACE, "  Parsing past monitor formula=[%s]", formula);
		if( parse_policy(formula, &n, &p_monitor->formulas) ){
			plog(LOG_TRACE, "Error parsing formula [%s]", formula);
			free(p_monitor);
			return R_ERROR;
		}

		// Computing size of allocated memory
		memcount = 0;
		memcount += sizeof(monitor_t);

		p_monitor->id = strdup(id);
		p_monitor->formula = strdup(formula);
		p_monitor->usec_timestep = usec_timestep;

		// Creating sav and cur state tables
		p_monitor->n_formulas = n;
		p_monitor->s_cur = (state_t *)malloc(sizeof(state_t) * n);
		p_monitor->s_sav = (state_t *)malloc(sizeof(state_t) * n);

		// Initialize the states after memory allocation
		for(i=0; i<n; i++) {
			p_monitor->s_cur[i].value = FALSE;
			p_monitor->s_cur[i].immutable = FALSE;
			p_monitor->s_cur[i].count_true = 0;
			p_monitor->s_cur[i].was_ever_true = FALSE;
			p_monitor->s_cur[i].was_ever_false = FALSE;
			p_monitor->s_cur[i].saved_values = NULL;

			p_monitor->s_sav[i].value = FALSE;
			p_monitor->s_sav[i].immutable = FALSE;
			p_monitor->s_sav[i].count_true = 0;
			p_monitor->s_sav[i].was_ever_true = FALSE;
			p_monitor->s_sav[i].was_ever_false = FALSE;
			p_monitor->s_sav[i].saved_values = NULL;
		}

		memcount += sizeof(state_t) * n * 2;

		// allocate the time window arrays for
		// the BEFORE operators with the window size
		plog (LOG_TRACE, "  Allocating past monitor memory");
		for(i=0; i < p_monitor->n_formulas; i++) {
			if (
					p_monitor->formulas[i].op==BEFORE ||
					p_monitor->formulas[i].op==WITHIN ||
					p_monitor->formulas[i].op==DURING ||
					p_monitor->formulas[i].op==REPLIM
			) {
				// allocate the circular array
				// TODO: we use now an integer to store the history (TRUE/FALSE), so it takes
				// a lot of bits to store one bit of information. Change this to a bit-level
				// to increase efficiency
				p_monitor->s_cur[i].saved_values = (c_array_t *)malloc(sizeof(c_array_t));
				p_monitor->s_sav[i].saved_values = (c_array_t *)malloc(sizeof(c_array_t));
				memcount += sizeof(c_array_t) * 2;
				// allocate the positions
				p_monitor->s_cur[i].saved_values->values = (int *)malloc(sizeof(int) * p_monitor->formulas[i].op1);
				p_monitor->s_sav[i].saved_values->values = (int *)malloc(sizeof(int) * p_monitor->formulas[i].op1);
				memcount += sizeof(int) * p_monitor->formulas[i].op1 * 2;
				// the current pointer for the saved values
				// that is implemented as a circular array
				p_monitor->s_cur[i].saved_values->p_first=0;
				p_monitor->s_cur[i].saved_values->p_next=0;
			}
		}

		plog (LOG_TRACE, "  Total memory allocated for past monitor %d", memcount);

		// Set initial monitor state to inactive
		p_monitor->is_active = FALSE;

		// Inserting monitor in table
		new_entry = (entry_t *)malloc(sizeof(entry_t));
		new_entry->name = strdup(id);
		new_entry->value = (void *)p_monitor;

		pthread_mutex_lock(&past_monitor_mtx);
		insert(&past_monitor_table, new_entry);
		pthread_mutex_unlock(&past_monitor_mtx);

		plog (LOG_TRACE, "-");
		return R_SUCCESS;

	} else {
		plog (LOG_ERROR, "Monitor id=[%s] already exists", id);
		return R_ERROR;
	}
}

void delete_past_monitor(char *id) {
	entry_t *entry;
	monitor_t *p_monitor;
	int i;
	plog (LOG_DEBUG, "Deleting monitor id=[%s]", id);
	entry = lookup(&past_monitor_table, id);
	if(entry){
		p_monitor = (monitor_t *)entry->value;
		// Synchronized
		pthread_mutex_lock(&past_monitor_mtx);
		free(p_monitor->id);
		free(p_monitor->formula);
		for(i=0; i < p_monitor->n_formulas; i++) {
			if (
					p_monitor->formulas[i].op==BEFORE ||
					p_monitor->formulas[i].op==WITHIN ||
					p_monitor->formulas[i].op==DURING ||
					p_monitor->formulas[i].op==REPLIM
			) {
				free(p_monitor->s_cur[i].saved_values->values);
				free(p_monitor->s_cur[i].saved_values);
			}
		}
		free(p_monitor->formulas);
		// free(p_monitor->s_pre);
		free(p_monitor->s_cur);
		delete_entry(&past_monitor_table, id);
		pthread_mutex_unlock(&past_monitor_mtx);
	}
}

monitor_t *lookup_past_monitor(char *id) {
	entry_t *entry;
	monitor_t *p_monitor;
	entry = lookup(&past_monitor_table,id);
	if(entry) {
		p_monitor = (monitor_t *)entry->value;
		return p_monitor;
	}
	return NULL;
}

void activate_past_monitor(char *id) {
	monitor_t *p_monitor = lookup_past_monitor(id);
	plog (LOG_DEBUG, "Activating past monitor id=[%s]", id);
	if(p_monitor) {

		// Synchronized
		// Not sure if all this code should be synchronized
		pthread_mutex_lock(&past_monitor_mtx);

		// Reset start time and last update time
		p_monitor->usec_start = usec_now();
		p_monitor->usec_last  = p_monitor->usec_start;

		// Reset timestep to one
		p_monitor->timestep = 1;

		// TODO: reset s_cur state in the monitor
		// need to go through all the sates
		/*
    for(i=0; i<p_monitor->n_formulas; i++) {
      p_monitor->s_sav[i].value = FALSE;
      p_monitor->s_sav[i].was_ever_true = FALSE;
      plog(LOG_TRACE, "%d %d", p_monitor->s_sav[i].value, p_monitor->s_sav[i].was_ever_true);
    }
		 */

		// set active
		p_monitor->is_active = TRUE;

		pthread_mutex_unlock(&past_monitor_mtx);
	}
}

void disactivate_past_monitor(char *id) {
	monitor_t *p_monitor = lookup_past_monitor(id);
	plog (LOG_DEBUG, "Disactivating past monitor id=[%s]", id);
	if(p_monitor) {
		// Synchronized
		pthread_mutex_lock(&past_monitor_mtx);
		p_monitor->is_active = FALSE;
		pthread_mutex_unlock(&past_monitor_mtx);
	}
}

int check_past_monitor_value(char *id) {
	monitor_t *p_monitor = lookup_past_monitor(id);
	// by default value is TRUE?
	int value = TRUE;
	if(p_monitor) {
		// Synchronized
		pthread_mutex_lock(&past_monitor_mtx);
		value = p_monitor->value;
		pthread_mutex_unlock(&past_monitor_mtx);
	}
	return value;
}

int update_past_monitor_by_id(char *id, event_t* new_event) {
	monitor_t *p_monitor = lookup_past_monitor(id);
	// by default value is TRUE?
	int value = TRUE;
	plog (LOG_DEBUG, "Updating policy monitor id=[%s]", id);
	if(p_monitor) {
		// Synchronized
		pthread_mutex_lock(&past_monitor_mtx);
		value = update_past_monitor(p_monitor, new_event);
		pthread_mutex_unlock(&past_monitor_mtx);
	}
	return value;
}

void update_all_past_monitors (event_t* new_event) {
	int i;
	entry_t *entry;
	monitor_t *p_monitor;

	// plog(LOG_TRACE,"Updating all past monitors");

	// Synchronize the update of all monitors
	pthread_mutex_lock(&past_monitor_mtx);

	// Iterate through table the contains all monitors
	for(i = 0; i < past_monitor_table->size_table; i++){

		entry = past_monitor_table->hash[i];

		//if entry exists and monitor is active
		if(entry) {
			p_monitor = (monitor_t *)entry->value;
			if (p_monitor->is_active) {
				update_past_monitor(p_monitor, new_event);
			}
		}

	}
	pthread_mutex_unlock(&past_monitor_mtx);

}



void plog_formula(char *fname, int i, state_t *cur_state) {
	char *val = "FALSE";
	if (cur_state->value) {
		val = "TRUE";
	}
	plog(LOG_DEBUG, "  Formula[%d] is %s (%s)", i, fname, val);
}

int update_past_monitor(monitor_t *p_monitor, event_t* new_event) {
	int64_t usec_cur, usec_elpsd_start, usec_elpsd_last, usec_diff;
	event_t *n_event;
	int i;
	formula_t *formula;
	state_t *cur_states  = p_monitor->s_cur;
	state_t *cur_state;
	c_array_t *sv;
	int IS_NULL_EVENT = FALSE;
	int IS_HISTORY_AVAILABLE = FALSE;

	if (new_event == NULL) {
		IS_NULL_EVENT = TRUE;
	}

	// Elapsed time since monitor was update
	usec_cur = usec_now();
	usec_elpsd_last = usec_cur - p_monitor->usec_last;

	// NULL events are generated to periodically check the time step and update monitor
	if (IS_NULL_EVENT) {
		usec_diff = usec_elpsd_last - p_monitor->usec_timestep;
		if (usec_diff < 0) {
			// Aborting update because the time step has not passed yet
			// plog_time(LOG_TRACE,"  Timestep difference      ", usec_diff);
			return(0);
		}

		plog(LOG_DEBUG, "- Updating [%s] timestep[%d]", p_monitor->id, p_monitor->timestep);

		usec_elpsd_start = usec_cur - p_monitor->usec_start;
		/*
    plog_time(LOG_TRACE,"  Start time                 ", p_monitor->usec_start);
    plog_time(LOG_TRACE,"  Last update time           ", p_monitor->usec_last);
		 */
		// Correct time substracting possible delay in the execution
		// because the difference between the timestep and the last time
		// the monitor was update will not be exactly the timestep
		p_monitor->usec_last = usec_cur - usec_diff;
		/*
    plog_time(LOG_TRACE,"  Corrected last update time ", p_monitor->usec_last);
    plog_time(LOG_TRACE,"  Current time               ", usec_cur);
    plog_time(LOG_TRACE,"  Elapsed since start        ", usec_elpsd_start);
    plog_time(LOG_TRACE,"  Elapsed since last update  ", usec_elpsd_last);
    plog_time(LOG_TRACE,"  Timestep                   ", p_monitor->usec_timestep);
    plog_time(LOG_TRACE,"  Timestep difference        ", usec_diff);
		 */

		// TODO: we should check if the usec_diff is bigger then a timestep,
		// this indicates that delay to evaluate the expressions is longer
		// then a timestep and probably the monitor/machine is overloaded
		// and not able to process updates on time

	} else {
		// updates triggered by event that are not null will only update
		// the respective nodes EALL and EFST in the formulas
		plog(LOG_DEBUG, "- Updating [%s] timestep[%d] event[%s] ", p_monitor->id, p_monitor->timestep, new_event->event_name);
		if (new_event->desired) {
			plog(LOG_DEBUG, "  Desired event received, saving state for recover", p_monitor->id, p_monitor->timestep, new_event->event_name);
			memcpy(p_monitor->s_sav, p_monitor->s_cur, sizeof(state_t) * p_monitor->n_formulas );
			for(i=0; i < p_monitor->n_formulas; i++) {
				if (
						p_monitor->formulas[i].op==BEFORE ||
						p_monitor->formulas[i].op==WITHIN ||
						p_monitor->formulas[i].op==DURING ||
						p_monitor->formulas[i].op==REPLIM
				) {
					memcpy(p_monitor->s_cur[i].saved_values,
							p_monitor->s_sav[i].saved_values,
							sizeof(c_array_t));
					memcpy(p_monitor->s_cur[i].saved_values->values,
							p_monitor->s_sav[i].saved_values->values,
							sizeof(int *) * p_monitor->formulas[i].op1);
				}
			}
		}
	}

	// TODO: we do not address simultaneous happening events, for instance,
	// if an event happens 3 times in one time step we only count one
	// and we also do not address order of events inside of a time step
	// The order of events is important for the mechanisms because they are
	// evaluated as soon as they arrive. This might lead to inconsistencies.

	/*
  for(i=0; i < p_monitor->n_formulas; i++){
    plog(LOG_TRACE,"%d",p_monitor->s_cur[i].value);
  }
	 */

	for(i=0; i < p_monitor->n_formulas; i++){

		// -Notes about observation and control monitor
		//
		// for observation monitor we do not need to update all the formula nodes
		// in case we receive a new event, because the violation will only occur
		// when we have null events that represent the timestep
		//
		//
		// for the control monitor this is not the case, we want to update all the nodes
		// to check if the formula was violated or not until that point in time
		//
		// The following code disable the update of all the formulas, only events are updated
		// if (new_event == NULL &&
		//   (p_monitor->actions[i].op==EFST  || p_monitor->actions[i].op==EALL)) continue;
		//
		formula = &(p_monitor->formulas[i]);
		cur_state = &(cur_states[i]);
		sv = cur_state->saved_values;

		switch(formula->op) {

		case T:
			cur_state->value = TRUE;
			plog_formula("TRUE", i, cur_state);
			break;

		case F:
			cur_state->value = FALSE;
			plog_formula("FALSE", i, cur_state);
			break;

		case EFST:
			if (!IS_NULL_EVENT) {
				n_event = &(formula->ev);
				if (A_is_refinement_of_B (new_event, n_event)) {
					cur_state->value = TRUE;
					// do we want to count events that happen
					// more then once per time step
					// cur_state->count_true++;
				}
			}
			plog_formula("EFST", i, cur_state);
			break;

		case EALL:
			if (!IS_NULL_EVENT) {
				n_event = &(formula->ev);
				if (A_is_refinement_of_B (new_event, n_event)) {
					cur_state->value = TRUE;
					// do we want to count events that happen
					// more then once per time step
					// cur_state->count_true++;
				}
			}
			plog_formula("EALL", i, cur_state);
			break;

		case XPATH:
			if (!IS_NULL_EVENT) {
				if (new_event->xml_doc!=NULL) {
					//print_element_names(new_event->xml_doc);
					cur_state->value = exec_xpath(new_event->xml_doc, formula->op1);
					//printf("T=%d F=%d cur_state=%d\n",TRUE,FALSE,cur_state->value);
					// cur_state->value = FALSE;
				} else {
					cur_state->value =  FALSE;
				}
			}
			plog_formula("XPATH", i, cur_state);
			plog(LOG_DEBUG, "    Expression = %s", formula->op1);
			break;

		case NOT:
			cur_state->value = !cur_states[formula->op1].value;
			plog_formula("NOT", i,cur_state);
			break;

		case AND:
			cur_state->value = cur_states[formula->op1].value && cur_states[formula->op2].value;
			plog_formula("AND", i,cur_state);
			break;

		case OR:
			cur_state->value = cur_states[formula->op1].value || cur_states[formula->op2].value;
			plog_formula("OR", i,cur_state);
			break;

		case IMPLIES:
			if (!cur_states[formula->op1].value) {
				cur_state->value = TRUE;
			} else {
				cur_state->value = cur_states[formula->op2].value;
			}
			plog_formula("IMPLIES", i,cur_state);
			break;

		case ALWAYS:
			// If formula op1 was ever false in the past ALWAYS
			// will evaluate to false independently of
			// the current value of op1
			if(!cur_state->immutable) {
				if(cur_states[formula->op1].value){
					cur_state->value = TRUE;
				} else {
					cur_state->value = FALSE;
					if (IS_NULL_EVENT) {
						cur_state->immutable = TRUE;
					}
				}
			}
			plog_formula("ALWAYS", i, cur_state);
			plog(LOG_TRACE, "    immutable (%d)", cur_state->immutable);
			break;

		case BEFORE:

			// There isn't enough history to evaluate
			IS_HISTORY_AVAILABLE = FALSE;
			if ((p_monitor->timestep - formula->op1) > 0) {
				IS_HISTORY_AVAILABLE = TRUE;
			}

			// Temporary variable pointing to circular buffer
			sv = cur_state->saved_values;
			if (IS_HISTORY_AVAILABLE) {
				// If history is available recover the first value
				if (sv->values[sv->p_first]) {
					cur_state->value = TRUE;
				} else {
					cur_state->value = FALSE;
				}
			} else {
				// If there isn't history formula is TRUE   //ACCORDING TO THE OSL PAPER IT MUST BE FALSE -E-
				cur_state->value = FALSE;
			}

			// End of a time step
			if (IS_NULL_EVENT) {
				// Update the circular buffer pointers
				// When there is enough history first==next
				if (IS_HISTORY_AVAILABLE) {
					sv->p_first++;
					if (sv->p_first==formula->op1) {
						sv->p_first=0;
					}
				}
				// Save the current value of op2 in the array
				sv->values[sv->p_next] = cur_states[formula->op2].value;
				// Increment next pointer
				sv->p_next++;
				// Reset next if bigger then array size
				if (sv->p_next==formula->op1) {
					sv->p_next=0;
				}
			}

			plog_formula("BEFORE", i, cur_state);
			plog(LOG_TRACE, "    Elapsed time since start (%d usec)", usec_elpsd_start);
			plog(LOG_TRACE, "    Time window   op1        (%d)", formula->op1);
			plog(LOG_TRACE, "    Saved history op2        (%d)", cur_states[formula->op2].value);
			break;


		case WITHIN:

			// There isn't enough history to evaluate
			IS_HISTORY_AVAILABLE = FALSE;
			if ((p_monitor->timestep - formula->op1) > 0) {
				IS_HISTORY_AVAILABLE = TRUE;
			}

			// Temporary variable pointing to circular buffer
			sv = cur_state->saved_values;
			if (IS_HISTORY_AVAILABLE) {
				// At least once within the previous time steps
				int cmp_val = cur_states[formula->op2].count_true;
				if (cur_states[formula->op2].value) {
					cmp_val++;
				}
				if (cmp_val > 0) {
					cur_state->value = TRUE;
				} else {
					cur_state->value = FALSE;
				}
			} else {
				// If there isn't history formula is TRUE
				cur_state->value = TRUE;
			}

			// End of a time step
			if (IS_NULL_EVENT) {
				// Update the circular buffer pointers
				// When there is enough history first==next
				if (IS_HISTORY_AVAILABLE) {
					// If the formula was true discount
					// the true from the counter of true values
					if (sv->values[sv->p_first]) {
						cur_states[formula->op2].count_true--;
					}
					sv->p_first++;
					if (sv->p_first==formula->op1) {
						sv->p_first=0;
					}
				}
				// Add counter if true in the current time step
				if (cur_states[formula->op2].value) {
					cur_states[formula->op2].count_true++;
				}
				// Save the current value of op2 in the array
				sv->values[sv->p_next] = cur_states[formula->op2].value;
				// Increment next pointer
				sv->p_next++;
				// Reset next if bigger then array size
				if (sv->p_next==formula->op1) {
					sv->p_next=0;
				}
			}
			plog_formula("WITHIN", i, cur_state);
			plog(LOG_TRACE, "    Elapsed time since start (%d usec)", usec_elpsd_start);
			plog(LOG_TRACE, "    Time window - op1        (%d)", formula->op1);
			plog(LOG_TRACE, "    Saved history op2        (%d)", cur_states[formula->op2].value);
			plog(LOG_TRACE, "    Count true next step op2 (%d)", cur_states[formula->op2].count_true);
			break;

		case DURING:

			// There isn't enough history to evaluate
			IS_HISTORY_AVAILABLE = FALSE;
			if ((p_monitor->timestep - formula->op1) > 0) {
				IS_HISTORY_AVAILABLE = TRUE;
			}

			// Temporary variable pointing to circular buffer
			sv = cur_state->saved_values;
			if (IS_HISTORY_AVAILABLE) {
				// During all previously time steps
				int cmp_val = cur_states[formula->op2].count_true;
				if (cur_states[formula->op2].value) {
					cmp_val++;
				}
				if (cmp_val == formula->op1) {
					cur_state->value = TRUE;
				} else {
					cur_state->value = FALSE;
				}
			} else {
				// If there isn't history formula is TRUE
				cur_state->value = TRUE;
			}

			// End of a time step
			if (IS_NULL_EVENT) {
				// Update the circular buffer pointers
				// When there is enough history first==next
				if (IS_HISTORY_AVAILABLE) {
					// If the formula was true discount
					// the true from the counter of true values
					if (sv->values[sv->p_first]) {
						cur_states[formula->op2].count_true--;
					}
					sv->p_first++;
					if (sv->p_first==formula->op1) {
						sv->p_first=0;
					}
				}
				// Add counter if true in the current time step
				if (cur_states[formula->op2].value) {
					cur_states[formula->op2].count_true++;
				}
				// Save the current value of op2 in the array
				sv->values[sv->p_next] = cur_states[formula->op2].value;
				// Increment next pointer
				sv->p_next++;
				// Reset next if bigger then array size
				if (sv->p_next==formula->op1) {
					sv->p_next=0;
				}
			}
			plog_formula("WITHIN", i, cur_state);
			plog(LOG_TRACE, "    Time window - op1        (%d)", formula->op1);
			plog(LOG_TRACE, "    Saved history op2        (%d)", cur_states[formula->op2].value);
			plog(LOG_TRACE, "    Count true next step op2 (%d)", cur_states[formula->op2].count_true);
			break;


		case REPLIM:

			// There isn't enough history to evaluate
			IS_HISTORY_AVAILABLE = FALSE;
			if ((p_monitor->timestep - formula->op1) > 0) {
				IS_HISTORY_AVAILABLE = TRUE;
			}

			// Temporary variable pointing to circular buffer
			sv = cur_state->saved_values;
			if (IS_HISTORY_AVAILABLE) {
				// During all previously time steps
				if (
						(cur_states[formula->op4].count_true >=  formula->op2) &&
						(cur_states[formula->op4].count_true <= formula->op3)
				) {
					cur_state->value = TRUE;
				} else {
					cur_state->value = FALSE;
				}
			} else {
				// If there isn't history formula is TRUE
				cur_state->value = TRUE;
			}

			// End of a time step
			if (IS_NULL_EVENT) {
				// Update the circular buffer pointers
				// When there is enough history first==next
				if (IS_HISTORY_AVAILABLE) {
					// If the formula was true discount
					// the true from the counter of true values
					if (sv->values[sv->p_first]) {
						cur_states[formula->op4].count_true--;
					}
					sv->p_first++;
					if (sv->p_first==formula->op1) {
						sv->p_first=0;
					}
				}
				// Add counter if true in the current time step
				if (cur_states[formula->op4].value) {
					cur_states[formula->op4].count_true++;
				}
				// Save the current value of op2 in the array
				sv->values[sv->p_next] = cur_states[formula->op4].value;
				// Increment next pointer
				sv->p_next++;
				// Reset next if bigger then array size
				if (sv->p_next==formula->op1) {
					sv->p_next=0;
				}
			}
			plog_formula("REPLIM", i, cur_state);
			plog(LOG_TRACE, "    Elapsed time since start (%d usec)", usec_elpsd_start);
			plog(LOG_TRACE, "    Time window          - op1 (%d)", formula->op1);
			plog(LOG_TRACE, "    Lower limit          - op2 (%d)", formula->op2);
			plog(LOG_TRACE, "    Upper limit          - op3 (%d)", formula->op3);
			plog(LOG_TRACE, "    Saved history        - op4 (%d)", cur_states[formula->op4].value);
			plog(LOG_TRACE, "    Count true next step - op4 (%d)", cur_states[formula->op4].count_true);
			break;

			// this is not evaluated anymore
			/*
      case UNTIL:
        plog(LOG_TRACE, "Formula node[%d] is UNTIL", i);
        // We stop checking after the until event arrives
        // and if there was no violation it won't violate anymore
        if(!cur_state->immutable) {
          // op1 is currently true, and counter+1 is bigger then zero (it has happen)
          int cmp_val = cur_states[formula->op1].count_true;
          if (cur_states[formula->op1].value) {
            cmp_val++;
          }
          if(
              // op2 happen
              cur_states[formula->op2].value &&
              // and op1 has not happen
              (cmp_val == 0)
          ) {
            cur_state->value = FALSE;
          } else {
            // In case op2 does not happen we don't care
            cur_state->value = TRUE;
          }

          // We only update the counter at the end of the time step
          // if the formula was not violated
          if (IS_NULL_EVENT) {
            // op2 already happen so the formula will not change anymore
            if(cur_states[formula->op2].value) {
              cur_state->immutable = TRUE;
            }
            if(cur_states[formula->op1].value) {
              //update counter if op2 has happened
              cur_states[formula->op2].count_true++;
            }
          }
        }
        plog_formula("UNTIL", i,cur_state);
        plog(LOG_TRACE, "    immutable         (%d)", cur_state->immutable);
        plog(LOG_TRACE, "    op1 value         (%d)", cur_states[formula->op1].value);
        plog(LOG_TRACE, "    op1 count_true    (%d)", cur_states[formula->op1].count_true);
        plog(LOG_TRACE, "    op2 value         (%d)", cur_states[formula->op2].value);
        break;
			 */

		case SINCE:
			// A since B = since(A, B)
			// A = op1 / B = op2

			if (cur_states[formula->op2].value &&
					!cur_states[formula->op2].was_ever_true
			) {
				// First time B happens
				cur_state->value = TRUE;
			} else {
				if (!cur_state->immutable) {
					if (cur_states[formula->op2].value ||
							cur_states[formula->op2].was_ever_true
					) {
						if (cur_states[formula->op1].value) {
							cur_state->value = TRUE;
						} else {
							cur_state->value = FALSE;
						}
					} else {
						cur_state->value = TRUE;
					}
				}
			}

			// We update the states
			if (IS_NULL_EVENT) {
				if (!cur_state->value) {
					cur_state->immutable=TRUE;
				}
				if (cur_states[formula->op2].value) {
					cur_states[formula->op2].was_ever_true = TRUE;
					cur_state->immutable=FALSE;
				}
			}

			plog_formula("SINCE", i, cur_state);
			plog(LOG_TRACE, "    immutable         (%d)", cur_state->immutable);
			plog(LOG_TRACE, "    op2 was_ever_true (%d)", cur_states[formula->op2].was_ever_true);
			break;

		case REPSINCE:
			// A(n) since B = repsince(n, A, B)
			// n = op1 / A = op2 / B = op3
			plog(LOG_TRACE, "Formula node[%d] is REPSINCE", i);

			if (cur_states[formula->op3].value &&
					!cur_states[formula->op3].was_ever_true
			) {
				// B was never TRUE and is not TRUE now
				// first time B appears, it is TRUE
				cur_state->value = TRUE;
			} else {
				int cmp_val = cur_states[formula->op2].count_true;
				if (cur_states[formula->op2].value) {
					cmp_val++;
				}
				if (cur_states[formula->op3].value ||
						cur_states[formula->op3].was_ever_true
				) {
					// B is TRUE now or already happen before
					if (cmp_val <= formula->op1 || cur_states[formula->op3].value) {
						// A count true is not violated
						cur_state->value = TRUE;
					} else {
						// A count true violated
						cur_state->value = FALSE;
					}
				} else {
					cur_state->value = TRUE;
				}
			}

			// We update the states only with NULL event
			if (IS_NULL_EVENT) {
				if (cur_states[formula->op2].value) {
					cur_states[formula->op2].count_true++;
				}
				if (cur_states[formula->op3].value) {
					cur_states[formula->op3].was_ever_true = TRUE;
					cur_states[formula->op2].count_true = 0;
				}
			}

			plog_formula("REPSINCE", i,cur_state);
			plog(LOG_TRACE, "    immutable         (%d)", cur_state->immutable);
			plog(LOG_TRACE, "    op1               (%d)", formula->op1);
			plog(LOG_TRACE, "    op2 count_true    (%d)", cur_states[formula->op2].count_true);
			plog(LOG_TRACE, "    op3 was_ever_true (%d)", cur_states[formula->op3].was_ever_true);
			break;

		case REPMAX:
			// We stop checking after the formula was violated
			// because of the cardinality checking, once violated
			// it will be never true again
			if(!cur_state->immutable) {
				// check the counter and current state considering
				// that the counter is not updated yet
				if( (cur_states[formula->op2].value &&
						((cur_states[formula->op2].count_true + 1) <= formula->op1)) ||
						(!cur_states[formula->op2].value &&
								((cur_states[formula->op2].count_true) <= formula->op1))
				) {
					cur_state->value = TRUE;
				} else {
					cur_state->value = FALSE;
				}
				// We only update the counter at the end of the time step
				// if the formula was not violated
				if (IS_NULL_EVENT) {
					if(cur_states[formula->op2].value) {
						cur_states[formula->op2].count_true++;
					}
					if (!cur_state->value) {
						cur_state->immutable = TRUE;
					}
				}
			}
			plog_formula("REPMAX", i,cur_state);
			plog(LOG_TRACE, "    immutable      (%d)", cur_state->immutable);
			plog(LOG_TRACE, "    op1            (%d)", formula->op1);
			plog(LOG_TRACE, "    op2 count_true (%d)", cur_states[formula->op2].count_true);
			break;

		case DENYC:
			cur_state->value = TRUE;
			plog_formula("DENYC", i, cur_state);
			break;
		case DENYD:
			cur_state->value = TRUE;
			plog_formula("DENYD", i, cur_state);
			break;
		case LIMIT:
			cur_state->value = TRUE;
			plog_formula("LIMIT", i, cur_state);
			break;


		}
	}

	if(cur_states[p_monitor->n_formulas-1].value){
		plog(LOG_DEBUG, "  Monitor id=[%s] timestep=[%d] value=[TRUE]", p_monitor->id, p_monitor->timestep);
		p_monitor->value = TRUE;
	}  else {
		plog(LOG_DEBUG, "  Monitor id=[%s] timestep=[%d] value=[FALSE]", p_monitor->id, p_monitor->timestep);
		// We may choose to deactivate the monitor
		//p_monitor->state = INACTIVE;
		p_monitor->value = FALSE;
	}

	if (IS_NULL_EVENT) {
		// Reset event nodes
		for(i=0; i < p_monitor->n_formulas; i++){
			formula = &(p_monitor->formulas[i]);
			if (formula->op==EFST || formula->op==EALL || formula->op==XPATH) {
				cur_states[i].value = FALSE;
			}
		}
		// Increment time step if the time step has passed
		p_monitor->timestep++;
	} else {
		if (new_event->desired) {
			plog(LOG_DEBUG, "  Desired event received, recovering state", p_monitor->id, p_monitor->timestep, new_event->event_name);
			memcpy(p_monitor->s_cur, p_monitor->s_sav, sizeof(state_t) * p_monitor->n_formulas );
			for(i=0; i < p_monitor->n_formulas; i++) {
				if (
						p_monitor->formulas[i].op==BEFORE ||
						p_monitor->formulas[i].op==WITHIN ||
						p_monitor->formulas[i].op==DURING ||
						p_monitor->formulas[i].op==REPLIM
				) {
					memcpy(p_monitor->s_sav[i].saved_values,
							p_monitor->s_cur[i].saved_values,
							sizeof(c_array_t));
					memcpy(p_monitor->s_sav[i].saved_values->values,
							p_monitor->s_cur[i].saved_values->values,
							sizeof(int *) * p_monitor->formulas[i].op1);
				}
			}
		}
	}

	plog(LOG_DEBUG, "-");
	return p_monitor->value;
}

