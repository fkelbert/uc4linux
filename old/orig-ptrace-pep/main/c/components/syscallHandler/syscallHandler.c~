/**
 * EventHandling file. It contains the all the methods needed in
 * order to gather the information of the events occured, that is
 * the information of the system calls that we acknowledge.
 *
 * @author Adrià Puigdomènech Badia
 *
 */
#include "syscallHandler.h"
#include "Constants.h"
#include "log_syscallHandler_pef.h"

#include "list_of_events.h"
#include <sys/stat.h>
/* Struct with a backup of the registers of the computer */
struct user_regs_struct backup;


GHashTable *pidfdtable;
GHashTable *pidtable;
GHashTable *userpidtable;
int firstcall = 1;
const unsigned int test_options = PTRACE_O_TRACECLONE |
				  PTRACE_O_TRACEFORK |
				  PTRACE_O_TRACEVFORK;

/*
 * Used to decide whether a filename is to be ignored by our program or not.
 *
 * @param filename Contains the string that describes de filename to be analyzed.
 *
 * @return Boolean which represents if the filename is to be ignored or not.
 *
 */
int may_ignore(char *filename)
{ //return FALSE;
  if((filename!=NULL) && (
      strcmp(filename,"/dev/tty")==0 ||
      strcmp(filename,"/etc/pwd.db")==0 ||
      strcmp(filename,"/etc/group")==0 ||
      strcmp(filename,"/etc/spwd.db")==0 ||
      strcmp(filename,"/etc/localtime")==0 ||
      strcmp(filename,"/home/user/.bash_rc")==0 ||
      strstr(filename,".bash_profile")!=NULL ||
      strstr(filename,".bash_login")!=NULL ||
      strstr(filename,".bash_logout")!=NULL ||
      strstr(filename,".bash_history")!=NULL ||
      strstr(filename,"/.Xauthority")!=NULL ||
      strstr(filename,".profile")!=NULL ||
      strstr(filename,"/etc/profile")!=NULL ||
      strstr(filename,"terminfo")!=NULL ||
      strstr(filename,"/usr/local/lib/")!=NULL ||
      strstr(filename,"/usr/lib/")!=NULL ||
      strstr(filename,"/usr/share/")!=NULL ||
      strstr(filename,"/usr/local/firefox35/")!=NULL ||
      strstr(filename,"/usr/X11R6/")!=NULL ||
      strstr(filename,"/home/user/.icon")!=NULL ||
      strstr(filename,"/var/run/ld.so.hints")!=NULL ||
      strstr(filename,"/var/tmp/")!=NULL ||
      strstr(filename,"/var/cache/fontconfig/")!=NULL ||
      strstr(filename,"/etc/fonts/")!=NULL ||
      strstr(filename,"/var/run/")!=NULL ||
      strstr(filename,"/.")!=NULL || //no hidden files/folders monitored, but relatives paths like ../../ are not allowed...
      strcmp(filename,".")==0 ||
      strcmp(filename,"..")==0
  ))
  {
    log_debug("Ignoring file access [%s]", filename);
    return TRUE;
  }
  return FALSE;
}


/*
 * Converts a decimal integer value to a string containing its binary
 * representation.
 *
 * @param x Integer to be converted.
 *
 * @return String representing the converted integer to binary.
 */

const char *byte_to_binary (int x){
	static char b[17];
	/* Set the end character for the string */
	b[0] = '\0';
	int z;
	/* Shift the bits until we are done */
	for (z = 32768; z > 0; z >>= 1)
	{
		/* Compare the last bit and concatenate the corresponding bit */
		strcat(b, ((x & z) == z) ? "1" : "0");
	}

	return b;
}

/*
 * Gets the information about the user of a determined process.
 *
 * @param pid Pid of the process whose user information is desired to know.
 *
 * @return Structure with the user information.
 */
struct passwd *getUserInfo(int pid){
	FILE *f;
	char filename[512];
	char buffer[512];
	int uid, dummy;
	struct passwd *user_info = NULL;
	/* Open the status file of the process in order to know
	 * the user id of the process */
	sprintf(filename,"/proc/%d/status",pid);
	f=fopen(filename,"r");
	/* Scan the file until we find the uid */
	do{
		fscanf(f,"%s\t%d\t%d",buffer, &dummy,&uid);
	}while(strstr(buffer,"Uid") == NULL);
	/* Get the user struct from the uid */

	user_info = getpwuid (uid);
	return user_info;
}

/*
 * Allows a system call to be accomplished.
 *
 * @param pid The pid of the traced process.
 * @param event Contains the information of the system call to be allowed.
 *
 */
int allowSystemCall(int pid, event_ptr event){
	int status;
	long eax;
	long code;
	char *filename;
	char cflags[50];
	struct user_regs_struct regs;

	/* Get the registers of the computer */
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	/* Waiting for the return of the system call */
	/* Obtain the system call code */
	if (regs.orig_eax == SYS_socketcall){
		code = regs.ebx+SOCKET_OFFSET;
	}else{
		code = regs.orig_eax;
	}
	/* With ptrace we exit */
	if(code == SYS_ptrace){
		log_info("Ptrace detected!");
		exit(-1);
	}

	/* Get the return value */
	eax = regs.eax;
	switch (code) {
		case SYS_open:
		case SYS_creat:
			/* Add fd mapping */
			if(eax >= 0){
				store_fd_filename_mapping(pid, eax, eventGetParamValueString(event,"filename"));
			}
		case SYS_close:
			/* Delete the fd IF EXISTED */
			if (eax >= 0){
				delete_fd_filename_mapping(pid, regs.ebx);
			}
		case SYS_rename:
			//TODO: change all the fd containing name
			break;
		case SYS_fork:
		case SYS_vfork:
		case SYS_clone:
			/* Copy the fd mapping hashtable to a new pid one */
			if (eax > 0){
				copy_fd_filename_mapping(pid, eax);
				//ptrace(PTRACE_ATTACH, eax,NULL, NULL);
			}
			break;
		case SYS_kill:
			/* Release the fd mapping hashtable */
			if(eax > 0){
				delete_table(regs.ebx);
			}
		case SYS_fcntl:
		case SYS_dup:
		case SYS_dup2:
			if (code==SYS_fcntl){
				if (regs.ecx!=F_DUPFD){
					break;
				}
			}
			/* Duplicate the fd */
			if (eax >= 0){
				filename = get_file_name(pid, regs.ebx);
				if (filename != NULL){
					if(code == SYS_dup2){
						store_fd_filename_mapping(pid, regs.ecx, filename);
					}else{
						store_fd_filename_mapping(pid, eax, filename);
					}
				}
			}

			break;
		default:
			break;
	}
	/* Register eax has the return value, so we get it.
	 * In mmap2 this is a pointer. */
	if (code == SYS_mmap2){
		sprintf(cflags,"%lx",eax);
		eventAddParamString(event,"retval",cflags);
	}else{
		eventAddParamInt(event,"retval",eax);
	}
	return 0;
}

/*
 * Denies a system call to be accomplished.
 *
 * @param pid The pid of the traced process.
 * @param event Contains the information of the system call to be denied.
 *
 * @return Integer representing the success of the denial.
 */
int denySystemCallBefore(int pid, event_ptr event){
	int status;
	long eax;
	long code, firstcode;
	/* Struct with the registers of the computer */
	struct user_regs_struct regs;


	/* We obtain the system call */
	/* Obtain the system call code */
	if (backup.orig_eax == SYS_socketcall){
		code = backup.ebx+SOCKET_OFFSET;
	}else{
		code = backup.orig_eax;
	}

	switch (code) {
		case SYS_pipe:
			/* We input two invalid descriptors*/
			ptrace(PTRACE_POKEDATA, pid, backup.ebx, -1);
			ptrace(PTRACE_POKEDATA, pid, backup.ebx+ADDRESS_SIZE, -1);
			break;
		case SYS_write:
		case SYS_pwrite64:
		case SYS_writev:
			/* Set the buffer pointing to NULL */
			backup.ecx = 0;
			ptrace(PTRACE_SETREGS, pid, NULL, &backup);
			break;
		case SYS_sendto:
		case SYS_sendmsg:
			/* Set the buffer pointing to NULL */
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + ADDRESS_SIZE, NULL);
			break;
		case SYS_truncate:
		case SYS_unlink:
		case SYS_kill:
		case SYS_rename:
		case SYS_open:
		case SYS_creat:
			/* Set the path to NULL. For kill this is setting
			 * silent mode. */
			backup.ebx = 0;
			ptrace(PTRACE_SETREGS, pid, NULL, &backup);
			break;
		case SYS_ftruncate:
		case SYS_close:
			/* Set a wrong file descriptor */
			backup.ebx = -1;
			ptrace(PTRACE_SETREGS, pid, NULL, &backup);
			break;
		default:
			break;
	}
	return 0;
}

/*
 * Denies a system call to be accomplished.
 *
 * @param pid The pid of the traced process.
 * @param event Contains the information of the system call to be denied.
 *
 * @return Integer representing the success of the denial.
 */
int denySystemCallAfter(int pid, event_ptr event){

	struct user_regs_struct regs;
	/* Get the registers of the system call */
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	int code = syscallToInt(eventGetParamValueString(event, "command"));
	/* With ptrace we exit */
	if(code == SYS_ptrace){
		log_info("Ptrace detected!");
		exit(-1);
	}
	/* We clean the flags we may have stained */
	regs.eflags = 0;
	/* Now we look the code of the system call to know what type it is */
	switch (code) {
		case SYS_accept: //Set errno?
			/* Set the struct sockaddr and socklen value to NULL */
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + ADDRESS_SIZE, NULL);
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + 2*ADDRESS_SIZE, NULL);
			regs.eax = -1;
			break;
		case SYS_recvfrom:
			/* Set the struct sockaddr and socklen value to NULL */
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + 4*ADDRESS_SIZE, NULL);
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + 5*ADDRESS_SIZE, NULL);
			/* We clear the received buffer */
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + ADDRESS_SIZE, NULL);
			regs.eax = -1;
			break;
		case SYS_recvmsg:
			/* We clear the received buffer */
			ptrace(PTRACE_POKEDATA, pid, regs.ecx + ADDRESS_SIZE, NULL);
			regs.eax = -1;
			break;
		case SYS_readv:
		case SYS_pread64:
		case SYS_read:
			/* For these functions, we clear the buffer, stored in the
			 * second argument of the system call */
			regs.ecx = 0;
			regs.eax = -1;
			break;
		case SYS_socket:
		case SYS_dup:
			/* We close the opened file descriptor */
			if (regs.eax >= 0){
				close(regs.eax);
				regs.eax = -1;
			}
			break;
		case SYS_pipe:
		case SYS_write:
		case SYS_pwrite64:
		case SYS_writev:
		case SYS_truncate:
		case SYS_ftruncate:
		case SYS_sendto:
		case SYS_sendmsg:
		case SYS_close:
		case SYS_unlink:
		case SYS_kill:
		case SYS_rename:
		case SYS_open:
		case SYS_creat:
			regs.eax = -1;
			break;
		case SYS_fork:
		case SYS_vfork:
			/* We kill the created child */
			if(regs.eax > 0){
				kill(regs.eax, SIGTERM);
				regs.eax = -1;
			}
			break;
		case SYS_fcntl:
			/* If it is the duplication command, we close the file descriptor */
			if ((regs.ecx == F_DUPFD)&&(regs.eax >= 0)){
				close(regs.eax);
				regs.eax = -1;
			}
			break;
		case SYS_dup2:
			/* We close the new descriptor */
			/* In dup2 that is the 2nd argument */
			if (regs.eax >= 0){
				close(regs.ecx);
				regs.eax = -1;
			}
			break;
		case SYS_mmap2:
			/* We free the allocated area, pointed by the
			 * return value */
			if (regs.eax >= 0){
				free((void *) regs.eax);
			}
			/* We return the error MAP_FAILED */
			regs.eax = -1;
			break;
		default:
			break;
	}
	ptrace(PTRACE_SETREGS, pid, NULL, &regs);
	eventAddParamInt(event,"retval",regs.eax);
	return 0;
}

/*
 * Actuates depending on the pdp response received.
 *
 * @param eventResponse Object containing the information of the response of the pdp.
 * @param pid Pid of the traced process.
 *
 */

void processResponseBefore(notifyResponse_ptr eventResponse, int pid, int direct)
{
  int result;
  if((eventResponse != NULL)&&(eventResponse->authorizationAction != NULL)
		  &&(eventResponse->authorizationAction->response != ACTION_ALLOW)){
	  denySystemCallBefore(pid,eventResponse->event);
  }
}

/*
 * Prepares an automatic response with respect to an event.
 *
 * @param event The event to which we are preparing the response.
 * @param action The code of the action of the response.
 *
 * @return The prepared response.
 *
 */

notifyResponse_ptr prepareResponse(event_ptr event, int action){
	notifyResponse_ptr response = notifyResponseNew(event);
	if (action == ACTION_ALLOW){
		response->authorizationAction = authorizationActionNew(strdup("ALLOW"), ACTION_ALLOW, 0, NULL);
	}else{
		response->authorizationAction = authorizationActionNew(strdup("INHIBIT"), ACTION_INHIBIT, 0, NULL);
	}
	log_info("Preparing direct response");
	return response;
}

/*
 * Actuates depending on the pdp response received.
 *
 * @param eventResponse Object containing the information of the response of the pdp.
 * @param pid Pid of the traced process.
 * @param direct Integer indicating whether the response has been consulted to the
 * pdp or not.
 *
 */

void processResponseAfter(notifyResponse_ptr eventResponse, int pid, int direct){
  int result;

  /* If no mechanism is given we stop here */
  if((eventResponse == NULL)||(eventResponse->authorizationAction == NULL)) {
	  log_trace("- Event allowed because there is no triggered mechanism");
	  if(eventResponse->event == NULL){
		  log_info("Syscall [ALLOWED]");
		  return;
	  }
	  result = allowSystemCall(pid,eventResponse->event);
	  if (result != -1){
	  		log_info("Syscall [ALLOWED]");
	  }
	  return;
  }
  if(direct == 0)	eventLog("Mechanisms triggered due to event: ", eventResponse->event);
  /* Allow or deny the system call */
  if((eventResponse->authorizationAction->response == ACTION_ALLOW)){;
	result = allowSystemCall(pid,eventResponse->event);
	if (result != -1){
		log_info("Syscall [ALLOWED]");
	}
  }else{
	result = denySystemCallAfter(pid,eventResponse->event);
	if(result != -1){
		log_info("Syscall [DENIED]");
	}else{
		log_info("Syscall could not be denied");
	}

  }

  /* Delay syscall for X microseconds (NOT seconds!) */
  if(eventResponse->authorizationAction->delay != 0)
  {
    log_info("  Syscall delayed (for [%llu] us)", eventResponse->authorizationAction->delay);
    usleep(eventResponse->authorizationAction->delay);
  }

  unsigned int i;

  /* Execute actions according to the policy */
  for(i = 0; i < eventResponse->authorizationAction->cntExecuteActions; i++)
  {
    printf ("\n\n\n\n\n\nr_actions->n_actions=%d r_actions->execute[i].id=%s\n\n\n\n\n\n",
        eventResponse->authorizationAction->cntExecuteActions, eventResponse->authorizationAction->executeActions[i]->actionDesc->actionName);
    if( strcmp(eventResponse->authorizationAction->executeActions[i]->actionDesc->actionName, "resetMonitor")==0)
    {
      log_info(" Resetting monitor");
    }

    else if( strcmp(eventResponse->authorizationAction->executeActions[i]->actionDesc->actionName, "encryptWrite")==0)
      printf("<Encrypt Write>\n");
    else if( strcmp(eventResponse->authorizationAction->executeActions[i]->actionDesc->actionName,"encryptRead")==0)
      printf("<Encrypt Read>\n");
    else if( strcmp(eventResponse->authorizationAction->executeActions[i]->actionDesc->actionName,"encryptOpen")==0)
      printf("<Encrypt Open>\n");
    else if( strcmp(eventResponse->authorizationAction->executeActions[i]->actionDesc->actionName,"encryptClose")==0)
      printf("<Encrypt Close>\n");
  } // for(i = 0; i < r_actions->n_actions_to_execute; i++)
}

/*
 * Stores the common parameters for most system call.
 *
 * @param pid Id of the traced process of the system call
 * @param inCall Boolean that indicates if it is the intro or the ending of the system call
 * @param code Identification code of the system call
 *
 * @return Event with the added standard parameters
 */

event_ptr processStandardParameters(int pid, bool inCall, int code){
	/* Structure with the user information of the process */
	struct passwd *user_info;
	actionDescription_ptr actionDesc;
	/* Structure that will gather the information of the system call */
	event_ptr event = NULL;
	char cflags[50];

	/* Assign it its name */
	actionDesc=actionDescriptionFind(pdp->actionDescStore, DFM_eventnames[code], TRUE);
	event=eventNew(actionDesc, inCall);
	/* Set the pid parameter */
	eventAddParamInt(event, "pid", pid);

	/* Set the command name */
	sprintf(cflags,"%s", DFM_eventnames[code]);
	eventAddParamString(event, "command", cflags);

	/* Set the user that triggered the system call */
	eventAddParamString(event, "user", get_userpid_value(pid));

	return event;

}

/*
 * Gathers the information related to a given system call.
 * NOTATION: 1st argument -> ebx register
 * 2nd argument -> ecx register
 * 3rd argument -> edx register
 * NOTE: When the parameters of the event are exposed, the pid parameter is not
 * written, but it is counted.
 *
 * @param pid Process related to the event.
 * @param firstcode Code of the system call.
 *
 * @return Structure containing the information of the system call, or null if
 * we do not care about it.
 */

event_ptr parseSyscall(pid_t pid, long firstcode, bool inCall) {
	/* Auxiliar variables for strings and arguments */
	char filename[512], filename2[512];
	char *p_filename;
	char *p_filename2;
	int fd2;
	char cflags[50];
	int fd;
	int arrfd[2];
	int status;
	int c_param;
	char *command;
	int handle=0;
	int count, i;
	int size;
	struct stat st;
	event_ptr event = NULL;
	paramDescription_ptr paramDesc = NULL;
	actionDescription_ptr actionDesc;

	/* Instance that parses the strings contained in the arguments of a
		 * system call */
	 bool isTry = inCall;
	long eax;
	long code, reg1, reg2;
	/* Struct with the registers of the computer */
	struct user_regs_struct regs;

	/* Get the registers of the system call */
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	ptrace(PTRACE_GETREGS, pid, NULL, &backup);
	/* If the system call is socketcall, any of the socket functions
	 * (accept, socket, bind, recvfrom, recvmsg,...) can be executed.
	 * This is determined by the first argument of socketcall(), so we
	 * add an offset to this argument to distinguish between these
	 * calls. */
	if (firstcode == SYS_socketcall){

		code = regs.ebx+SOCKET_OFFSET;
	}else{
		code = firstcode;
	}

	/* Now we look the code of the system call to know what type it is */
	switch (code) {

	case SYS_exit:
	case SYS_socket:
	case SYS_accept:
		/* Event parameters: command, user, {status || domain,type || sockfd}, (return val)
		* That is 5 paramters. */


		event = processStandardParameters(pid,inCall,code);
		/* Set the status || domain,type || sockfd parameter  */
		switch (code) {
			case SYS_exit:
				/* It is the first parameter of exit */
				eventAddParamInt(event,"status",regs.ebx);
				break;
			case SYS_socket:
				/* Domain and type is an array pointed by the second argument of the
				 * socket call */
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx, NULL);
				reg2 = ptrace(PTRACE_PEEKDATA, pid, regs.ecx+ADDRESS_SIZE, NULL);
				sprintf(cflags, "%ld,%ld", reg1,reg2);
				eventAddParamString(event,"domain, type",cflags);
				break;
			case SYS_accept:
				/* The socket file descriptor is the second argument of accept */
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx, NULL);
				eventAddParamInt(event,"sockfd",reg1);
				break;
		}


		break;
	case SYS_ptrace:
	case SYS_clone:
		/* Processing just the usual parameters */
		event =processStandardParameters(pid,inCall,code);
		break;


	case SYS_pipe:
		/* The file descriptors of pipe are an array pointed by the first argument of the
		 * pipe call, first source then destination */
		fd = ptrace(PTRACE_PEEKDATA, pid, regs.ebx, NULL);
		fd2 = ptrace(PTRACE_PEEKDATA, pid, regs.ebx+ADDRESS_SIZE, NULL);

		/* Event parameters are: command, user, fdsource, fddests  (+return value)
				 * that is 6 parameters */
		event = processStandardParameters(pid,inCall,code);
		/* Set the file descriptor source */
		eventAddParamInt(event, "source", fd);

		/* Set the file descriptor destination */
		eventAddParamInt(event, "dest", fd2);

		break;

	case SYS_open:
	case SYS_creat:
		/* We allocate a string to retrieve the string of
		 * the open/creat filename. */
		p_filename = (char *)calloc(DEFAULT_LENGTH+1, sizeof(char));
		/* The string is located in the first argument */
		getString(pid, regs.ebx, p_filename);
		/* If the call has a filename to be ignored, we do not need more information */
		if ((IGNORE_SYS_FILES)&&(may_ignore(p_filename))) {
			actionDesc=actionDescriptionFind(pdp->actionDescStore, DFM_eventnames[code], TRUE);
			event=eventNew(actionDesc, inCall);
			return event;
		} else {
			/* Event parameters are: command, user, filename, and flags  (+return value)
			 * So, it has 6 parameters.
			 */
			event = processStandardParameters(pid,inCall,code);

			/* Set the filename, stored in the string worker instance */
			eventAddParamString(event,"filename",p_filename);
			/* Get the flags of the system call, stored in the second argument */
			eventAddParamString(event,"flags",byte_to_binary(regs.ecx));

			free(p_filename);
				//plog(LOG_INFO," %s [%s] -----------------------------------------------------------O_TRUNC=%d cflags=(%s)%d\n", syscallnames[code],	filename,O_TRUNC, byte_to_binary(sys_msg->msg_data.msg_ask.args[1]),sys_msg->msg_data.msg_ask.args[1]);
		}
		break;

	case SYS_recvfrom:
	case SYS_recvmsg:
	case SYS_readv:
	case SYS_pread64:
	case SYS_read:
		/* If the call has a filename to be ignored, we do not need more information */
		if ((IGNORE_SYS_FILES)&&(may_ignore(p_filename))) {
			actionDesc=actionDescriptionFind(pdp->actionDescStore, DFM_eventnames[code], TRUE);
			event=eventNew(actionDesc, inCall);
			return event;
		} else {
			/* Parameters: command user fd [filename] buffer_addr (+retval)
			 * So these are 6/7 paramenters.
			 */
			event = processStandardParameters(pid,inCall,code);
			/* Set the filedescriptor */
			switch (code){
				case SYS_read:
				case SYS_readv:
				case SYS_preadv:
					/* These calls have the file descriptor in the first argument */
					eventAddParamInt(event,"filedescriptor",regs.ebx);
					p_filename = NULL;
					p_filename = get_file_name(pid, regs.ebx);
					if (p_filename == NULL){
						p_filename = strdup("<empty>");
					}
					eventAddParamString(event,"filename",p_filename);
					break;
				case SYS_recvfrom:
				case SYS_recvmsg:
					/* These calls have the file descriptor in the address pointed by its
					 * second argument
					 */
					reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx, NULL);
					eventAddParamInt(event,"filedescriptor",reg1);
					break;
			}
			/* Set buffer destination address */
			switch (code){
				case SYS_read:
				case SYS_readv:
				case SYS_pread64:
					/* These calls have the destination buffer address stored in the second argument */
					sprintf(cflags,"%lx",regs.ecx);
					break;
				case SYS_recvfrom:
				case SYS_recvmsg:
					/* These calls have the destination buffer address in the second position of an
					 * array pointed by the second argument of the call */
					reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+ADDRESS_SIZE, NULL);
					sprintf(cflags,"%lx",reg1);
					break;
			}
			eventAddParamString(event,"buf dest addr",cflags);

			/* Add the size parameter */
			/* In read and pwrite64, it is stored in the third
			 * argument of the system call*/
			if((code == SYS_read)||(code == SYS_pread64)){
				eventAddParamInt(event, "sizea", regs.edx);
			}
			/* In readv, have to sum all the lengths
			 * of the strings in the vector pointed by the
			 * second argument, and the number of strings is
			 * given by the third argument */
			if(code == SYS_readv){
				count = 0;
				for(i=0;i<regs.edx;i++){
					count += ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+(2*i + 1)*ADDRESS_SIZE, NULL);
				}
				eventAddParamInt(event, "sizea", count);
			}
			/* In recvfrom, it is stored in the third position
			 * of the vector pointed by the second argument of the call */
			if(code == SYS_recvfrom){
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+2*ADDRESS_SIZE, NULL);
				eventAddParamInt(event, "sizea", reg1);
			}
			/* In recvmsg, it is like in writev but the address of the vector
			 * is given by the third position of the vector pointed by the
			 * second argument of recvmsg, and the arguments are pointed by
			 * the second argument of the socketcall system call
			 */
			if(code == SYS_recvmsg){
				/* Get the address of the msghdr structure */
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+ADDRESS_SIZE, NULL);
				/* Get the address of the iovector */
				reg2 = ptrace(PTRACE_PEEKDATA, pid,  reg1+2*ADDRESS_SIZE, NULL);
				/* Get the number of strings to count */
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  reg1+3*ADDRESS_SIZE, NULL);
				/* Proceed like in readv */
				count = 0;
				for(i=0;i<reg1;i++){
					count += ptrace(PTRACE_PEEKDATA, pid,  reg2+(2*i + 1)*ADDRESS_SIZE, NULL);
				}
				eventAddParamInt(event, "sizea", count);
			}
		}
		break;

	case SYS_write:
	case SYS_pwrite64:
	case SYS_writev:
	case SYS_truncate:
	case SYS_ftruncate:
//		case SYS_connect:
	case SYS_sendto:
	case SYS_sendmsg:
		/* Sendto and sendmsg only contain file descriptor.
		 * Truncate only contains the filename.
		 * Ftruncate and write calls contain the file descriptor and
		 * may also add a filename. */
		/* Get the filename or the file descriptor of the system call */
		p_filename = NULL;
		fd = -1;
		if (code==SYS_truncate){
			p_filename = (char *)calloc(DEFAULT_LENGTH+1, sizeof(char));
			/* The filename is in the first argument of the call */
			getString(pid,regs.ebx,p_filename);
		}else {
			if((code == SYS_sendto)||(code == SYS_sendmsg)){
				/* The file descriptor is in the second argument */
				fd = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx, NULL);
			}else{
				/* The file descriptor is in the first argument */
				fd = regs.ebx;
				p_filename = get_file_name(pid, regs.ebx);
				if (p_filename == NULL){
						p_filename = "<empty>";
				}
			}
		}

		/* If the call has a filename to be ignored, we do not need more information */
		if ((IGNORE_SYS_FILES)&&(may_ignore(p_filename))) {
			actionDesc=actionDescriptionFind(pdp->actionDescStore, DFM_eventnames[code], TRUE);
			event=eventNew(actionDesc, inCall);
			return event;
		} else {
			/* Parameters: command user [filename] [filedescriptor] (+retval)
			 * So we have 5/6 parameters */
			event = processStandardParameters(pid,inCall,code);

			/* Set the filename parameter */
			if(p_filename != NULL){
				eventAddParamString(event, "filename", p_filename);
			}
			/* Set the filedescriptor character */
			if (code!=SYS_truncate){
				eventAddParamInt(event, "filedescriptor", fd);
			}
			/* Add the size parameter */
			/* In (f)truncate, it is stored in the
			 * second argument of the system call */
			if((code == SYS_truncate) || (code == SYS_ftruncate) ){
				eventAddParamInt(event, "sizea", regs.ecx);
			}
			/* In write and pwrite64, it is stored in the third
			 * argument of the system call*/
			if((code == SYS_write)||(code == SYS_pwrite64)){
				eventAddParamInt(event, "sizea", regs.edx);
			}
			/* In writev, have to sum all the lengths
			 * of the strings in the vector pointed by the
			 * second argument, and the number of strings is
			 * given by the third argument */
			if(code == SYS_writev){
				count = 0;
				for(i=0;i<regs.edx;i++){
					count += ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+(2*i + 1)*ADDRESS_SIZE, NULL);
				}
				eventAddParamInt(event, "sizea", count);
			}
			/* In sendto, it is stored in the third position
			 * of the vector pointed by the second argument of the call */
			if(code == SYS_sendto){
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+2*ADDRESS_SIZE, NULL);
				eventAddParamInt(event, "sizea", reg1);
			}
			/* In sendmsg, it is like in writev but the address of the vector
			 * is given by the third position of the vector pointed by the
			 * second argument of sendmsg, and the arguments are pointed by
			 * the second argument of the socketcall system call
			 */
			if(code == SYS_sendmsg){
				/* Get the address of the msghdr structure */
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  regs.ecx+ADDRESS_SIZE, NULL);
				/* Get the address of the iovector */
				reg2 = ptrace(PTRACE_PEEKDATA, pid,  reg1+2*ADDRESS_SIZE, NULL);
				/* Get the number of strings to count */
				reg1 = ptrace(PTRACE_PEEKDATA, pid,  reg1+3*ADDRESS_SIZE, NULL);
				/* Proceed like in writev */
				count = 0;
				for(i=0;i<reg1;i++){
					count += ptrace(PTRACE_PEEKDATA, pid,  reg2+(2*i + 1)*ADDRESS_SIZE, NULL);
				}
				eventAddParamInt(event, "sizea", count);
			}
		}
		break;

	case SYS_close:
		/* Parameters are: command user filedescriptor retval
		 * So the number of parameters is 5 */
		event = processStandardParameters(pid,inCall,code);

		/* The filedescriptor is the first argument of the system call */
		eventAddParamInt(event, "filedescriptor", regs.ebx);

		/* We add the file name, if possible */
		p_filename = get_file_name(pid, regs.ebx);
		if (p_filename == NULL){
				p_filename = "<empty>";
		}
		eventAddParamString(event, "filename", p_filename);

		break;

	case SYS_unlink:
	case SYS_execve:
		if (code==SYS_execve){
			/* Execve stops three times */

			if (firstcall == 1){

				p_filename = strdup("Executed File");
				size = 0;
			}else{
				p_filename = (char *)calloc(DEFAULT_LENGTH+1, sizeof(char));
				/* The filename is in the first argument of the call */
				getString(pid,regs.ebx,p_filename);
				stat(filename, &st);
				size = st.st_size;
			}

		} else {
			/* The filename is pointed in the first argument of the program */
			p_filename = (char *)calloc(DEFAULT_LENGTH+1, sizeof(char));
			getString(pid,regs.ebx,p_filename);
		}

		/* If the call has a filename to be ignored, we do not need more information */
		if ((IGNORE_SYS_FILES)&&(may_ignore(p_filename))) {
			/* Assign it its name */
			actionDesc=actionDescriptionFind(pdp->actionDescStore, DFM_eventnames[code], TRUE);
			/* Create the event structure */
			event=eventNew(actionDesc, inCall);
			return event;

		} else {
			/* Parameters: command user filename (+retval)
			 * So we have 5 parameters.
			 */
			event = processStandardParameters(pid,inCall,code);
			/* Set the filename parameter */
			eventAddParamString(event,"filename", p_filename);
			/*
			 * We add the size parameter
			 */
			if (code == SYS_execve){
				eventAddParamInt(event, "sizea", size);
			}
		}
		break;
	case SYS_kill:
		/* Parameters: command user target signal (+retval)
		 * So we have 6 parameters.
		 */
		event = processStandardParameters(pid,inCall,code);
		/* Set the pid to kill, that is the first argument of the call */
		eventAddParamInt(event,"target",regs.ebx);

		/* Set the signal parameter, which is the second parameter of the call */
		eventAddParamInt(event, "signal", regs.ecx);

		/* Set the size parameter */
		eventAddParamInt(event, "sizea", 4);

		break;

	case SYS_rename:
		/* The old filename is pointed by the first argument of the call,
		 * and the new filename is pointed by the second argument of the call */
		p_filename = (char *)calloc(DEFAULT_LENGTH+1, sizeof(char));
		p_filename2 = (char *)calloc(DEFAULT_LENGTH+1, sizeof(char));
		getString(pid,regs.ebx,p_filename);
		getString(pid,regs.ecx,p_filename2);
		/* Event parameters: command, user, old filename, new filename (+retval)
		 * So we have 6 parameters.
		 */
		event = processStandardParameters(pid,inCall,code);
		/* Set the old filename */
		eventAddParamString(event, "oldfilename", p_filename);
		/* Set the new filename */
		eventAddParamString(event, "newfilename", p_filename2);
		//     plog(LOG_INFO," %s [%s]->[%s]\n", syscallnames[code], filename,filename2);

		break;

	case SYS_fork:
	case SYS_vfork:
		/* Event parameters: command, user, (retval)
		 * So we have 4 parameters.
		 */
		event = processStandardParameters(pid,inCall,code);
		break;

	case SYS_dup:
	case SYS_dup2:
	case SYS_fcntl:
		/* Look if the F_DUPFD of fcntl is set, which is the second argument of the
		 * fcntl call */
		handle=1;
		if (code==SYS_fcntl){
			if (regs.ecx!=F_DUPFD){
				handle=0;
			}
		}

		if (handle==1){
			/* Event parameters: command, user, fd, (retval)
			 * So we have 5 arguments
			 */
			event = processStandardParameters(pid,inCall,code);

			/* Set the file descriptor, stored in the first parameter
			 * of the call */
			eventAddParamInt(event, "filedescriptor", regs.ebx);

		} else {
			/* Assign it its name */
			actionDesc=actionDescriptionFind(pdp->actionDescStore, DFM_eventnames[code], TRUE);
			/* Create the event structure */
			event=eventNew(actionDesc, inCall);
			return event;
		}
		break;

	case SYS_mmap2:
		/* The file descriptor is stored in the fifth position of the array pointed by
		 * the first argument of the function.
		 */
		fd = ptrace(PTRACE_PEEKDATA, pid, regs.ebx + 4*ADDRESS_SIZE, NULL);
		/* Parameters: command user start length prot flags fd offset (+retval)
		 * So it has 10 parameters */
		event = processStandardParameters(pid,inCall,code);
		/* Set the start parameter, stored in the first position of the array
		 * pointed by the first argument of the function.
		 */
		sprintf(cflags,"%lx", ptrace(PTRACE_PEEKDATA, pid, regs.ebx, NULL));
		eventAddParamString(event, "start", cflags);
		/* Set the length parameter, stored in the second position of the array
		 * pointed by the first argument of the function.
		 */
		eventAddParamInt(event, "length",ptrace(PTRACE_PEEKDATA, pid, regs.ebx + ADDRESS_SIZE, NULL));

		/* Set the prot parameter, stored in the third position of the array
		 * pointed by the first argument of the function.
		 */
		eventAddParamString(event, "prot",byte_to_binary(ptrace(PTRACE_PEEKDATA, pid, regs.ebx + 2*ADDRESS_SIZE, NULL)));
		/* Set the flags parameter, stored in the fourth position of the array
		 * pointed by the first argument of the function.
		 */
		eventAddParamInt(event,"flags",ptrace(PTRACE_PEEKDATA, pid, regs.ebx + 3*ADDRESS_SIZE, NULL));

		/* Set the file descriptor */
		eventAddParamInt(event,"filedescriptor",fd);

		/* Set the offset parameter, stored in the sixth position of the array
		 * pointed by the first argument of the function.
		 */
		eventAddParamInt(event,"offset",ptrace(PTRACE_PEEKDATA, pid, regs.ebx + 5*ADDRESS_SIZE, NULL));

/*
			printf("-------------------PROT_READ  %x(%s)\n",PROT_READ,byte_to_binary(PROT_READ));
			printf("-------------------PROT_WRITE %x(%s)\n",PROT_WRITE,byte_to_binary(PROT_WRITE));
			printf("-------------------PROT_EXEC  %x(%s)\n",PROT_EXEC,byte_to_binary(PROT_EXEC));
			printf("-------------------PROT_NONE  %x(%s)\n",PROT_NONE,byte_to_binary(PROT_NONE));
*/


		break;
	default:
		event=NULL;
		break;
	}
	if(firstcall == 1){
		firstcall = 0;
	}
	return event;
}

/*
 * Fetch a string from an address in the memory space of a process.
 *
 * @param child Pid of the child.
 * @param addr Address in the memory space of the child.
 * @param dataStr String we want to retrieve.
 */
void getString(pid_t child, long addr, char *dataStr)
{

	int len = DEFAULT_LENGTH;
	char *laddr;
    int i, j;
    /* This structure will contain the final string */
    union u {
            long val;
            char chars[LONG_SIZE];
    }data;
    i = 0;
    j = len / LONG_SIZE;
    laddr = dataStr;
    /* We read characters of length long size, as it is how it
     * is done by ptrace */
    while(i < j) {
        data.val = ptrace(PTRACE_PEEKDATA, child, addr + i * ADDRESS_SIZE, NULL);
        memcpy(laddr, data.chars, LONG_SIZE);
        ++i;
        laddr += LONG_SIZE;
    }
    j = len % LONG_SIZE;
    /* If we have not finished we do last loop */
    if(j != 0) {
        data.val = ptrace(PTRACE_PEEKDATA, child, addr + i * ADDRESS_SIZE, NULL);
        memcpy(laddr, data.chars, j);
    }
    /* We leave the string well formated */
    dataStr[len] = '\0';
}

/*
 * Put a string to an address in the memory space of a child.
 *
 * @param child Pid of the child.
 * @param addr Address in the memory space of the child.
 * @param dataStr String to put in memory.
 *
 */
void putString(pid_t child, long addr, char *dataStr)
{
	int len = DEFAULT_LENGTH;
	char *laddr;
    int i, j;
    /* This structure will contain the string to put into
     * memory */
    union u {
            long val;
            char chars[LONG_SIZE];
    }data;
    i = 0;
    j = len / LONG_SIZE;
    laddr = dataStr;
    /* We write characters of length long size, as it is how it
     * is done by ptrace */
    while(i < j) {
        memcpy(data.chars, laddr, LONG_SIZE);
        ptrace(PTRACE_POKEDATA, child, addr + i * ADDRESS_SIZE, data.val);
        ++i;
        laddr += LONG_SIZE;
    }
    j = len % LONG_SIZE;
    /* If we have not finished we do last loop */
    if(j != 0) {
        memcpy(data.chars, laddr, j);
        ptrace(PTRACE_POKEDATA, child, addr + i * ADDRESS_SIZE, data.val);
    }
}


/*
 * Creates the hash table in order to map the filenames and file descriptors.
 *
 * @return Integer representing the success of the function.
 */

unsigned int initializeFDTable()
{
  log_info("Initializing file descriptors table");
  pidfdtable=g_hash_table_new(g_int_hash, g_int_equal);
  checkNullInt(pidfdtable, "Unable to create fd-mapping table");
  return R_SUCCESS;
}

/*
 * Stores a relation between a file descriptor and a filename of a process.
 *
 * @param pid Pid of the process we are referring to.
 * @param fd File descriptor of the relation.
 * @param filename Name of the file of the relation.
 *
 * @return Integer representing the success of the function.
 */

unsigned int store_fd_filename_mapping(int pid, int fd, char *filename)
{
  checkNullInt(filename, "Failure: Storing empty filename for mapping");
  GHashTable *lfdtable=g_hash_table_lookup(pidfdtable, &pid);
  if(lfdtable==NULL){
	  /* If the table for this pid is not defined, we initialize it
	   * and we add also the stdin, stdout and stderr file descriptors */
	  lfdtable=g_hash_table_new(g_int_hash, g_int_equal);
	  int i;
	  char *yVect[]={"stdin","stdout","stderr"};
	  for(i=0;i<3;i++){
		  unsigned int *b=(unsigned int*)memAlloc(sizeof(int));
		  *b=i;
		  g_hash_table_insert(lfdtable, b, yVect[i]);
	  }
	  int *y=(int*)memAlloc(sizeof(int));
	  *y=pid;
	  g_hash_table_insert(pidfdtable, y, lfdtable);
  }
  int *x=(int*)memAlloc(sizeof(int));
  *x=fd;
  g_hash_table_insert(lfdtable, x, strdup(filename));

  log_info("%s - Associated file descriptor [%d][%d] with [%s]",__func__, pid, fd, filename);

  return R_SUCCESS;
}

/*
 * Duplicates the filename to file descriptor mapping hash table of a process
 * for a new process.
 *
 * @param pid Pid of the process we are copying its hash table.
 * @param newpid Pid of the process we are copying the hash table to.
 *
 * @return Integer representing the success of the function.
 */
unsigned int copy_fd_filename_mapping(int pid, int newpid){
	GHashTable *lfdtable=g_hash_table_lookup(pidfdtable, &pid);
	if(lfdtable==NULL)	return R_SUCCESS;
	int *y=(int*)memAlloc(sizeof(int));
	*y = newpid;
	g_hash_table_insert(pidfdtable,y,lfdtable);
	log_debug("%s - copied the filename mapping table of [%d] to [%d]", __func__, pid, newpid);
	return R_SUCCESS;
}

/*
 * Deletes a mapping of the relation between a file name
 * and file descriptor.
 *
 * @param pid Pid of the process from whose table we are deleting this relation.
 * @param fd File descriptor in the relation to be removed.
 *
 * @return Integer representing the success of the function.
 */
unsigned int delete_fd_filename_mapping(int pid, int fd)
{
  GHashTable *lfdtable=g_hash_table_lookup(pidfdtable, &pid);
  if(lfdtable==NULL) return R_ERROR;
  else g_hash_table_remove(lfdtable, &fd);
  log_debug("%s - deleting the mapping [%d][%d]", __func__, pid, fd);
  return R_SUCCESS;
}

/*
 * Deletes a hash table containing the mapping of the file name
 * and file descriptor of a process.
 *
 * @param pid Pid of the process from whose table we are deleting the table.
 *
 * @return Integer representing the success of the function.
 */
unsigned int delete_table(int pid)
{
  g_hash_table_remove(pidfdtable, &pid);
  log_debug("%s - deleting the table for [%d]", __func__, pid);
  return R_SUCCESS;
}

/*
 * Fetches a file name from the relation between a file descriptor
 * and a filename of a process.
 *
 * @param pid Pid of the process we are referring to.
 * @param fd File descriptor of the relation.
 *
 * @return If found, the requested file name, NULL otherwise.
 */

char* get_file_name(int pid, int fd)
{
  if(fd < 0)	return NULL;
  log_debug("%s - Querying fd association [%d][%d]",__func__, pid, fd);
  GHashTable *lfdtable=g_hash_table_lookup(pidfdtable, &pid);
  if(lfdtable==NULL){
	  /* If the table for this pid is not defined, we create it
	   * and we add also the stdin, stdout and stderr file descriptors */
	  lfdtable=g_hash_table_new(g_int_hash, g_int_equal);
	  int i;
	  char *yVect[]={"stdin","stdout","stderr"};
	  for(i=0;i<3;i++){
		  unsigned int *b=(unsigned int*)memAlloc(sizeof(int));
		  *b=i;
		  g_hash_table_insert(lfdtable, b, yVect[i]);
	  }
	  char *filename=g_hash_table_lookup(lfdtable, &fd);
	  if(filename!=NULL) log_debug("%s - returning [%s]\n", __func__, filename);
	  else log_debug("%s - returning NULL", __func__);
	  int *y=(int*)memAlloc(sizeof(int));
	  *y=pid;
	  g_hash_table_insert(pidfdtable,y,lfdtable);
	  return filename;
  }else{
    char *filename=g_hash_table_lookup(lfdtable, &fd);
    if(filename!=NULL) log_debug("%s - returning [%s]\n", __func__, filename);
    else log_debug("%s - returning NULL", __func__);
    return filename;
  }
}

/*
 * Waits for the reception of a system call.
 *
 * @param child Pid of the process that is desired to be continued.
 * @param Waitingfor Pid of the process we are waiting for (-1 if we
 * wish to receive the changed state of any process.
 *
 * @return The pid of the process we have received a system call, or -1 if
 * all the childs have exited.
 */

int waitforCall(pid_t child, int Waitingfor){
	pid_t newpid;
	int status;
	pid_t caller_id;
	caller_id = child;
	struct inCall *inc;
	long eax, orig_eax, previous_orig_eax;
	int repeat;
	do{

		repeat = 0;
		/* Tell ptrace to wait for a system call */
		ptrace(PTRACE_SYSCALL, caller_id,NULL, NULL);
		caller_id = waitpid(Waitingfor, &status, __WALL);
		long code = ptrace(PTRACE_PEEKUSER, caller_id, ADDRESS_SIZE * ORIG_EAX, NULL);
		/* If the child exited, we stop tracing the process */
		if(WIFEXITED(status) || WIFSIGNALED(status) ){
			if(caller_id == -1){
					return -1;
			}
			delete_pid(caller_id);
			if(g_hash_table_size(pidtable) == 0){
				return -1;
			}
			continue;
		}
		if(caller_id == -1){
				return -1;
		}
		if(!WIFSTOPPED(status)){
			/* The child is not in a stopped state, it's running! The horror. */
			repeat = 1;
			continue;

		}
		inc = get_pid_value(caller_id);
		/* A child has been born. It's a guy. */
		if(inc == NULL){
			create_pid(caller_id);
			log_debug("New pid [%d]",caller_id);
			ptrace(PTRACE_SETOPTIONS, caller_id, NULL, test_options);
		}
		/* SIGSTOP is received due to an attachment of a child
		 * process. */
		if ((status >> 16 == PTRACE_EVENT_FORK) || (status >> 16 == PTRACE_EVENT_CLONE) ||
				(status >> 16 == PTRACE_EVENT_VFORK)) {
			repeat = 1;
			continue;
		}

		/* It's the stop signal after a child is born */
		if (WSTOPSIG(status) == SIGSTOP){
			ptrace(PTRACE_SETOPTIONS, caller_id, NULL, test_options);
			ptrace(PTRACE_SYSCALL, caller_id,NULL, NULL);
			newpid = waitpid(Waitingfor, &status, __WALL);
			caller_id = newpid;
		}
		inc = get_pid_value(caller_id);
		/* Testing if we have stopped enough */
		if (inc->inCall == 1){
			eax =ptrace(PTRACE_PEEKUSER, caller_id, ADDRESS_SIZE * EAX, NULL);
			if(eax == -ENOSYS){
				/* Something is amiss */
				/* Look if it is a new call (we skipped one system call)
				 * or it is the prolongation of the last one  */
				orig_eax = ptrace(PTRACE_PEEKUSER, caller_id, ADDRESS_SIZE * ORIG_EAX, NULL);
				previous_orig_eax = inc->code;
				if(orig_eax == previous_orig_eax){
					/* Wait again */
					repeat = 1;
					continue;
				}else{
					/* New call */
					inc->inCall = 0;
					change_pid_value(caller_id, inc);
				}
			}
		}
	}while((WSTOPSIG(status) != SIGTRAP)||(repeat == 1));
	return caller_id;
}


/*
 * Creates the hash table in order to store the pid of the creted processes.
 *
 * @return Integer representing the success of the function.
 */

unsigned int initializePidTable()
{
  log_info("Initializing pid storing table");
  pidtable=g_hash_table_new(g_int_hash, g_int_equal);
  userpidtable=g_hash_table_new(g_int_hash, g_int_equal);
  checkNullInt(pidfdtable, "Unable to create pid storing table");
  return R_SUCCESS;
}

/*
 * Stores a new pid - Incall structure relation in a hash table as
 * well as the username of a process.
 *
 * @param pid Pid of the process we are referring to.
 *
 * @return Integer representing the success of the function.
 */
unsigned int create_pid(int pid)
{
  struct inCall *inc=g_hash_table_lookup(pidtable, &pid);
  char *username = g_hash_table_lookup(userpidtable, &pid);
  struct passwd *user_info;
  if(inc==NULL){
	  inc = (struct inCall *)memAlloc(sizeof(struct inCall));
	  inc->inCall = 0;
	  inc->eventResponse = NULL;
	  int *x=(int*)memAlloc(sizeof(int));
	  *x=pid;
	  g_hash_table_insert(pidtable, x, inc);
	  log_info("%s - Stored pid [%d]",__func__, pid);
      user_info = getUserInfo(pid);
      int *y=(int*)memAlloc(sizeof(int));
      *y=pid;
      g_hash_table_insert(userpidtable, y, user_info->pw_name);
  }
  return R_SUCCESS;
}

/*
 * Gets the user of a process.
 *
 * @param pid Pid of the process we are referring to.
 *
 * @return Integer representing the success of the function.
 */

char *get_userpid_value(int pid)
{
  char *result =g_hash_table_lookup(userpidtable, &pid);
  return result;
}

/*
 * Gets the Incall structure of a process
 *
 * @param pid Pid of the process we are referring to.
 *
 * @return Integer representing the success of the function.
 */

struct inCall *get_pid_value(int pid)
{
  struct inCall *result =g_hash_table_lookup(pidtable, &pid);
  return result;
}

/*
 * Deletes a pid - Incall structure relation in a hash table as
 * well as the username of a process.
 *
 * @param pid Pid of the process we are referring to.
 *
 * @return Integer representing the success of the function.
 */
unsigned int delete_pid(int pid)
{
  g_hash_table_remove(pidtable, &pid);
  g_hash_table_remove(userpidtable, &pid);
  log_info("%s - Deleted pid [%d]",__func__, pid);
  return R_SUCCESS;
}

/*
 * Substitutes the InCall structure of a process in a hash table.
 *
 * @param pid Pid of the process we are referring to.
 * @param inCall InCall structure to substitute the present one.
 *
 * @return Integer representing the success of the function.
 */
unsigned int change_pid_value(int pid, struct inCall *inc){
	g_hash_table_replace (pidtable, &pid, inc);
	return R_SUCCESS;
}




