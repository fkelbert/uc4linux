#include "as.h"
#include "log_as_axis_c.h"

static void bytes_to_string(unsigned char *string, unsigned char *bytes, uint32_t len) {
    int i;
    int pointer = 0;
    for (i = 0; i < len; i++) {
        pointer += sprintf((char*) string + pointer, "%02x", bytes[i]);
    }
}

axiom_node_t *
axis2_as_attestFiles(const axutil_env_t *env, axiom_node_t *node) {
    axiom_node_t *files = NULL;
    axiom_node_t *file = NULL;
    axiom_node_t *next_file = NULL;
    axiom_element_t * file_ele = NULL;
    axiom_attribute_t * file_path_attrib = NULL;


    axiom_namespace_t * ns;
    axiom_node_t *return_node = NULL;
    axiom_element_t * return_node_ele = NULL;

    axiom_node_t *hash = NULL;
    axiom_element_t * hash_ele = NULL;

    axiom_node_t *signature = NULL;

    struct md * digest;
    unsigned char * hValue;

    UINT32 vLen;
    BYTE* vValue;

    AXIS2_ENV_CHECK(env, NULL);

    if (node) {
        files = node;
        if (files) {
            return_node_ele = axiom_element_create(env, NULL, "attestationResult", NULL, &return_node);
            ns = axiom_namespace_create(env, "http://www.iese.fraunhofer.de/esf/1.0/AttestationService/soap", "soap");
            axiom_element_set_namespace(return_node_ele, env, ns, return_node);
            axiom_node_t * tmCertNode = getPrivacyCertificate(env); //get cert fun

            axiom_node_add_child(return_node, env, tmCertNode);

            if ((next_file = axiom_node_get_first_child(files, env)) != NULL) {
                do {
                    digest = (struct md*) malloc(sizeof (struct md));
                    file = next_file;
                    file_ele = axiom_node_get_data_element(file, env);

                    computeFileDigest("SHA1", axiom_element_get_attribute_value_by_name(file_ele, env, "path"), digest);

                    hash_ele = axiom_element_create(env, NULL, "hash", NULL, &hash);
                    hValue = (unsigned char *) malloc((2 * digest->valueLen + 1) * sizeof (unsigned char));
                    bytes_to_string(hValue, digest->value, digest->valueLen);
                    axiom_element_set_text(hash_ele, env, (char *) hValue, hash);
                    free(hValue);

                    file_path_attrib = axiom_attribute_create(env, "path", axiom_element_get_attribute_value_by_name(file_ele, env, "path"), ns);
                    next_file = axiom_node_get_next_sibling(file, env);
                    file_ele = axiom_element_create(env, NULL, "file", NULL, &file);
                    axiom_element_add_attribute(file_ele, env, file_path_attrib, file);

                    axiom_node_add_child(file, env, hash);

                    signature = getSignature(env, digest);

                    tpm_extendPCR(PCR, digest->valueLen, digest->value, &vLen, &vValue);
                    free(vValue);

                    free(digest);

                    axiom_node_add_child(file, env, signature);

                    axiom_node_add_child(return_node, env, file);

                } while (next_file);
            }
            axiom_node_t * tmQuoteNode = getPCRQuote(env); //get quote fun
            axiom_node_add_child(return_node, env, tmQuoteNode);
        }
    } else {
        AXIS2_ERROR_SET(env->error, AXIS2_ERROR_SVC_SKEL_INVALID_XML_FORMAT_IN_REQUEST, AXIS2_FAILURE);
        printf("ERROR: invalid XML in request\n");
        return_node_ele = axiom_element_create(env, NULL, "attestationResult", NULL, &return_node);
        axiom_element_set_text(return_node_ele, env, "ERROR: INVALID XML", return_node);
    }

    return return_node;
}

unsigned int registerAS(char * TMAddress) {
    const axutil_env_t *lenv = NULL;
    axis2_options_t *options = NULL;
    axis2_endpoint_ref_t* endpoint_ref = NULL;
    axis2_svc_client_t* svc_client = NULL;
    axiom_namespace_t * ns;

    lenv = axutil_env_create_all("ascomm.log", AXIS2_LOG_LEVEL_TRACE);
    options = axis2_options_create(lenv);
    endpoint_ref = axis2_endpoint_ref_create(lenv, TMAddress);
    axis2_options_set_to(options, lenv, endpoint_ref);
    axis2_options_set_action(options, lenv, "registerAttestationService");

    // path = AXIS2C_HOME environment variable -> possible to shift this into autogenerated header during compilation step using scons INSTALLDIR
    svc_client = axis2_svc_client_create(lenv, "../");
    if (svc_client == NULL) {
        AXIS2_LOG_ERROR(lenv->log, AXIS2_LOG_SI, "Stub invoke FAILED: Error code: %d :: %s", lenv->error->error_number, AXIS2_ERROR_GET_MESSAGE(lenv->error));
        return EXIT_FAILURE;
    }
    axis2_svc_client_set_options(svc_client, lenv, options);

    axiom_node_t * tmMsgNode = NULL;
    axiom_element_t * tmMsgElem = NULL;
    tmMsgElem = axiom_element_create(lenv, NULL, "attestationServiceRegistration", NULL, &tmMsgNode);
    ns = axiom_namespace_create(lenv, "http://www.iese.fraunhofer.de/esf/1.0/TrustManager/soap", "soap");
    axiom_element_set_namespace(tmMsgElem, lenv, ns, tmMsgNode);

    //AXIS2_LOG_DEBUG_MSG(env->log, "before priv cert");
    axiom_node_t * tmCertNode = getPrivacyCertificate(lenv); //get cert fun
    axiom_node_add_child(tmMsgNode, lenv, tmCertNode);
    //AXIS2_LOG_DEBUG_MSG(env->log, "after priv cert");

    //AXIS2_LOG_DEBUG_MSG(env->log, "before quote");
    axiom_node_t * tmQuoteNode = getPCRQuote(lenv); //get quote fun
    axiom_node_add_child(tmMsgNode, lenv, tmQuoteNode);
    //AXIS2_LOG_DEBUG_MSG(env->log, "after quote");


    axis2_svc_client_fire_and_forget(svc_client, lenv, tmMsgNode);

    if (svc_client) {
        axis2_svc_client_free(svc_client, lenv);
        svc_client = NULL;
    }
    if (lenv) {
        axutil_env_free((axutil_env_t *) lenv);
        lenv = NULL;
    }

    return EXIT_SUCCESS;
}

axiom_node_t * getPrivacyCertificate(const axutil_env_t *env) {
    axiom_node_t * tmCertNode = NULL;
    axiom_element_t * tmCertElem = NULL;

    FILE *fp;
    long len;
    char *buf;

    fp = fopen(CERT_FILE, "rb");
    fseek(fp, 0, SEEK_END);
    len = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    buf = (char *) calloc(len + 1, sizeof (char));
    fread(buf, len, 1, fp);
    fclose(fp);


    tmCertElem = axiom_element_create(env, NULL, "privacyCertificate", NULL, &tmCertNode);
    axiom_element_set_text(tmCertElem, env, buf, tmCertNode);

    free(buf);

    return tmCertNode;
}

axiom_node_t * getPCRQuote(const axutil_env_t *env) {
    axiom_node_t * tmQuoteNode = NULL;
    axiom_element_t * tmQuoteElem = NULL;

    unsigned char * Data;
    uint32_t dLen;

    unsigned char * ValidationData;
    uint32_t vLen;

    unsigned char * Message;
    uint32_t mLen;

    unsigned char prefix[9] = {0x00, 0x03, 0xff, 0xff, 0xff, 0x00, 0x00, 0x01, 0xe0}; //0003ffffff000001e
    uint32_t pLen = 9;

    unsigned char * elemText;

    tmQuoteElem = axiom_element_create(env, NULL, "pcrQuote", NULL, &tmQuoteNode);

    int quote_failed = tpm_getQuote(&dLen, &Data, &vLen, &ValidationData);

    if (quote_failed == EXIT_SUCCESS) {
        mLen = (pLen + TPM_SHA1_160_HASH_LEN * 24);
        Message = (unsigned char *) malloc(mLen * sizeof (BYTE));
        memcpy(Message, prefix, pLen);

        int i;
        for (i = 0; i < 24; i++) {
            BYTE* value;
            UINT32 vLen;
            tpm_getPCR(i, &vLen, &value);
            memcpy(Message + pLen + i * TPM_SHA1_160_HASH_LEN, value, TPM_SHA1_160_HASH_LEN);
            free(value);
        }

        elemText = malloc((mLen * 2 + dLen * 2 + vLen * 2 + 1 + 1 + 1) * sizeof (unsigned char));
        bytes_to_string(elemText, Message, mLen);
        memcpy(elemText + 2 * mLen, "\n", 1);

        bytes_to_string(elemText + +2 * mLen + 1, Data, dLen);
        memcpy(elemText + 2 * mLen + 1 + 2 * dLen, "\n", 1);

        bytes_to_string(elemText + 2 * mLen + 1 + 2 * dLen + 1, ValidationData, vLen);

        strcpy((char *) (elemText + 2 * mLen + 1 + 2 * dLen + 1 + vLen * 2), "");

        axiom_element_set_text(tmQuoteElem, env, (char *) elemText, tmQuoteNode);

        free(Data);
        free(ValidationData);
        free(Message);
        free(elemText);
    } else {
        axiom_element_set_text(tmQuoteElem, env, "QUOTE", tmQuoteNode);
    }

    return tmQuoteNode;

}

axiom_node_t * getSignature(const axutil_env_t *env, struct md* digest) {
    axiom_node_t * tmSignatureNode = NULL;
    axiom_element_t * tmSignatureElem = NULL;

    unsigned char * sign;
    uint32_t sLen;
    unsigned char * sValue;

    int hash_failed = tpm_getSignedHash(digest->valueLen, digest->value, &sLen, &sign);
    tmSignatureElem = axiom_element_create(env, NULL, "signature", NULL, &tmSignatureNode);
    if (hash_failed == EXIT_SUCCESS) {
        sValue = (unsigned char *) malloc((2 * sLen + 1) * sizeof (unsigned char));
        bytes_to_string(sValue, sign, sLen);
        free(sign);
        axiom_element_set_text(tmSignatureElem, env, (char *) sValue, tmSignatureNode);
        free(sValue);
    } else {
        axiom_element_set_text(tmSignatureElem, env, "", tmSignatureNode);
    }

    return tmSignatureNode;

}

axis2_svc_skeleton_t *
axis2_as_create(const axutil_env_t *env) {
    axis2_svc_skeleton_t *svc_skeleton = NULL;
    svc_skeleton = AXIS2_MALLOC(env->allocator,
            sizeof (axis2_svc_skeleton_t));

    svc_skeleton->ops = &as_svc_skeleton_ops_var;

    svc_skeleton->func_array = NULL;

    return svc_skeleton;
}

int AXIS2_CALL
as_init(axis2_svc_skeleton_t *svc_skeleton,
        const axutil_env_t *env) {

    tpm_connect(SRK_PASS);
    tpm_loadKey();
    registerAS(TM_URL);

    svc_skeleton->func_array = axutil_array_list_create(env, 0);
    axutil_array_list_add(svc_skeleton->func_array, env, "attestFiles");

    return AXIS2_SUCCESS;
}

axiom_node_t* AXIS2_CALL
as_invoke(axis2_svc_skeleton_t *svc_skeleton,
        const axutil_env_t *env,
        axiom_node_t *node,
        axis2_msg_ctx_t *msg_ctx) {

    return axis2_as_attestFiles(env, node);
}

axiom_node_t* AXIS2_CALL
as_on_fault(axis2_svc_skeleton_t *svc_skeli,
        const axutil_env_t *env, axiom_node_t *node) {
    axiom_node_t *error_node = NULL;
    axiom_node_t* text_node = NULL;
    axiom_element_t *error_ele = NULL;
    error_ele = axiom_element_create(env, node, "AttestationServiceError", NULL,
            &error_node);
    axiom_element_set_text(error_ele, env, "Attestation Service failed ",
            text_node);

    return error_node;
}

int AXIS2_CALL
as_free(axis2_svc_skeleton_t *svc_skeleton,
        const axutil_env_t *env) {
    if (svc_skeleton->func_array) {
        axutil_array_list_free(svc_skeleton->func_array, env);
        svc_skeleton->func_array = NULL;
    }

    if (svc_skeleton) {

        AXIS2_FREE(env->allocator, svc_skeleton);
        svc_skeleton = NULL;
    }

    return AXIS2_SUCCESS;
}

AXIS2_EXPORT int
axis2_get_instance(axis2_svc_skeleton_t **inst,
        const axutil_env_t *env) {
    *inst = axis2_as_create(env);
    if (!(*inst)) {

        return AXIS2_FAILURE;
    }

    return AXIS2_SUCCESS;
}

AXIS2_EXPORT int
axis2_remove_instance(axis2_svc_skeleton_t *inst,
        const axutil_env_t *env) {
    axis2_status_t status = AXIS2_FAILURE;
    if (inst) {
        status = AXIS2_SVC_SKELETON_FREE(inst, env);
    }
    return status;
}
