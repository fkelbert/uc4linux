# logger configuration-Skript
import os, glob, re, fileinput, stat, sys
Import('env','curBaseDir','buildDir')

# multiple replace function
def mtplReplace(repllist, str):
  regex=re.compile("(%s)" % "|".join(map(re.escape, repllist.keys())))
  return regex.sub(lambda mo: repllist[mo.string[mo.start():mo.end()]], str)

workingdir=""
pathSeparator='/'
if sys.platform == "win32":
	pathSeparator="\\"

if curBaseDir==env['ESFBASE']+pathSeparator+'libraries'+pathSeparator+'logger':
  files=[env['ESFBASE']+'/include/logger/loggerconf.h']
else:
  oldpath=os.getcwd()
  os.chdir(curBaseDir)
  workingdir=curBaseDir
  files=[]
  files=glob.glob(os.path.join(curBaseDir,'*.c'))  
#  files=glob.glob(os.path.join(curBaseDir,'*.c*'))

genfiles={}
if GetOption('clean') or GetOption('help'):    # for cleaning return filenames of additional logger configuration headers
  for curfile in files:
    LOGBASENAME=curfile[curfile.rfind(pathSeparator)+1:]
    genfiles[LOGBASENAME]="log_"+LOGBASENAME.replace('.','_')+".h"
  Return('genfiles')

print "checking logger configuration in directory" + curBaseDir
for curfile in files:
  LOGBASENAME=curfile[curfile.rfind(pathSeparator)+1:]
  print "   checking " + LOGBASENAME + ":",
  if LOGBASENAME == "loggerconf.h" or LOGBASENAME == "c/include/logger/loggerconf.h":
    ## TODO: improvement: check whether stdout/stderr usage is commented
    lfile = open(curfile)
    found=0
    file=open(buildDir+'/logger_base.h', 'w')
    file.write("#ifndef _LOGGER_BASE_H\n")
    file.write("#define _LOGGER_BASE_H\n")
    logoutputs=[]

    for line in lfile:
      #if 'stdout' in line: print line
      m=re.search('std(out|err)', line)
      if ( (m != None) and (line.startswith("//")==False and line.startswith(" *")==False) and not ('GLOBAL_LOG_OUTPUT' in line) ):
        print "\nFAILURE: stdout or stderr is present in configuration => this will destroy usual stdout/stderr file pointer!"
        Exit(1)

      x=re.search('_OUTPUT ', line)
      if (x != None) and (line.startswith("//")==False and line.startswith(" *")==False):
        clogoutput=(line[line.find("_OUTPUT ")+8:-1]).strip()
        if (clogoutput != "stdout" and clogoutput != "stderr") and not (clogoutput in logoutputs):
          logoutputs.append(clogoutput);
          file.write("static FILE *"+clogoutput+"=NULL;\n");
        else:
          # linux will complain about this redirection of file pointer as it is not constant
          # in linux stdout is defined as "struct _IO_FILE *" whereas in openbsd as "(&__sF[1])" so usual way produces compiler error
          # because of address operator &
          if ( (clogoutput == "stdout" or clogoutput == "stderr") and (sys.platform=="openbsd5")): #or sys.platform=="win32"
            file.write("static FILE *stdout1 = GLOBAL_LOG_OUTPUT;\n");
            file.write("#undef GLOBAL_LOG_OUTPUT\n");
            file.write("#define GLOBAL_LOG_OUTPUT stdout1\n");
          else:
			# win32 similar to openbsd (&_iob[1]) -> gcc fails due to not constant assignment
			if ( (clogoutput == "stdout" or clogoutput == "stderr") and (sys.platform=="win32")):
				file.write("#define STDOUTFLAG 1\n");
				file.write("static FILE *stdout1 = NULL;\n");
				file.write("#undef GLOBAL_LOG_OUTPUT\n");
				file.write("#define GLOBAL_LOG_OUTPUT stdout1\n");
		

      if 'static char *log_absPath' in line:
        fabspath=(line[line.find("log_absPath = ")+15:-3]).strip()
        if not fabspath.endswith('/'):
          print "\nFailure: Specified logging directory doesn't end with closing '/'"
          Exit(1)
        if not os.path.exists(fabspath):
          print "\nFailure: Specified logging directory (" + fabspath + ") doesn't exist"
          Exit(1)

        perm = os.stat(fabspath).st_mode
        permk = stat.S_IFDIR | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH
        if not (perm == permk):
          print "\nFailure: Specified logging directory (" + fabspath + ") has wrong permissions (" + str(perm ) + " instead of " + str(permk) + ")"
          Exit(1)

    if found==0:
      print "all sems to be ok"
    file.write("#endif\n")
    file.close()
    lfile.close()
    Return()

  LOGCONFFILE="log_"+LOGBASENAME.replace('.','_')+".h"
  LOGUPPER=("log_"+LOGBASENAME.replace('.','_')).upper()
  LOGLOWER=("log_"+LOGBASENAME.replace('.','_')).lower()

  LOGMODULENAME=LOGBASENAME[:LOGBASENAME.find('.')]
  if os.path.exists(buildDir+'/'+LOGCONFFILE)==False:
    print "generate configuration header... ",
    # changed for external build directory
    file=open(buildDir+'/'+LOGCONFFILE, 'w')
    filetemplate=open(env['ESFBASE'] + "/libraries/logger/logtemplate",'r')
    for line in filetemplate:
      repl={"${LOGUPPER}":LOGUPPER,"${LOGLOWER}":LOGLOWER,"${LOGCONFFILE}":LOGCONFFILE.replace('.','_'), "${LOGMODULENAME}":LOGMODULENAME }
      file.write(mtplReplace(repl,line))
    filetemplate.close()
    file.close()
  else:
    print "configuration header present; ",

  lfile=open(LOGBASENAME)
  found=0
  for line in lfile:
    m=re.search('#include "'+LOGCONFFILE+'"', line)
    if m != None:
      print "all seems to be ok"
      found=1
      break
  if found==0:
    print "include directive for logger configuration is missing ",
    lfile.close()

    inclpos=False
    for line in fileinput.input(LOGBASENAME, inplace=1):
      if line.startswith('#include'):
        inclpos=True
      else:
        if inclpos:
          print '#include \"'+LOGCONFFILE+'\"'
        inclpos=False
      print line,
    print "=> inserted"
  genfiles[LOGBASENAME]=LOGCONFFILE
Return('genfiles')
