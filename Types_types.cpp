/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace de { namespace tum { namespace in { namespace i22 { namespace uc { namespace thrift { namespace types {

int _kTStatusValues[] = {
  TStatus::OKAY,
  TStatus::ERROR,
  TStatus::ALLOW,
  TStatus::INHIBIT,
  TStatus::MODIFY,
  TStatus::ERROR_EVENT_PARAMETER_MISSING
};
const char* _kTStatusNames[] = {
  "OKAY",
  "ERROR",
  "ALLOW",
  "INHIBIT",
  "MODIFY",
  "ERROR_EVENT_PARAMETER_MISSING"
};
const std::map<int, const char*> _TStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTStatusValues, _kTStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTDetectionModeValues[] = {
  TDetectionMode::MISUSE,
  TDetectionMode::ANOMALY,
  TDetectionMode::COMBINED
};
const char* _kTDetectionModeNames[] = {
  "MISUSE",
  "ANOMALY",
  "COMBINED"
};
const std::map<int, const char*> _TDetectionMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTDetectionModeValues, _kTDetectionModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTConflictResolutionValues[] = {
  TConflictResolution::OVERWRITE,
  TConflictResolution::IGNORE_UPDATES,
  TConflictResolution::KEEP_ALL
};
const char* _kTConflictResolutionNames[] = {
  "OVERWRITE",
  "IGNORE_UPDATES",
  "KEEP_ALL"
};
const std::map<int, const char*> _TConflictResolution_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTConflictResolutionValues, _kTConflictResolutionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTAttributeNameValues[] = {
  TAttributeName::WILDCARD,
  TAttributeName::TYPE,
  TAttributeName::OWNER,
  TAttributeName::CLASS,
  TAttributeName::CREATION_TIME,
  TAttributeName::MODIFICATION_TIME,
  TAttributeName::SIZE
};
const char* _kTAttributeNameNames[] = {
  "WILDCARD",
  "TYPE",
  "OWNER",
  "CLASS",
  "CREATION_TIME",
  "MODIFICATION_TIME",
  "SIZE"
};
const std::map<int, const char*> _TAttributeName_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTAttributeNameValues, _kTAttributeNameNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTobiasStatusTypeValues[] = {
  TobiasStatusType::OK,
  TobiasStatusType::ERROR,
  TobiasStatusType::ALLOW,
  TobiasStatusType::INHIBIT,
  TobiasStatusType::MODIFY
};
const char* _kTobiasStatusTypeNames[] = {
  "OK",
  "ERROR",
  "ALLOW",
  "INHIBIT",
  "MODIFY"
};
const std::map<int, const char*> _TobiasStatusType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTobiasStatusTypeValues, _kTobiasStatusTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TChecksum::~TChecksum() throw() {
}


void TChecksum::__set_val(const tlong val) {
  this->val = val;
}

uint32_t TChecksum::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_val = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->val);
          isset_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_val)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TChecksum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TChecksum");

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TChecksum &a, TChecksum &b) {
  using ::std::swap;
  swap(a.val, b.val);
}

TChecksum::TChecksum(const TChecksum& other0) {
  val = other0.val;
}
TChecksum& TChecksum::operator=(const TChecksum& other1) {
  val = other1.val;
  return *this;
}
void TChecksum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TChecksum(";
  out << "val=" << to_string(val);
  out << ")";
}


TAttribute::~TAttribute() throw() {
}


void TAttribute::__set_name(const TAttributeName::type val) {
  this->name = val;
}

void TAttribute::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t TAttribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->name = (TAttributeName::type)ecast2;
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAttribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAttribute");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAttribute &a, TAttribute &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

TAttribute::TAttribute(const TAttribute& other3) {
  name = other3.name;
  value = other3.value;
}
TAttribute& TAttribute::operator=(const TAttribute& other4) {
  name = other4.name;
  value = other4.value;
  return *this;
}
void TAttribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAttribute(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TEvent::~TEvent() throw() {
}


void TEvent::__set_name(const std::string& val) {
  this->name = val;
}

void TEvent::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void TEvent::__set_isActual(const bool val) {
  this->isActual = val;
}

uint32_t TEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _ktype6;
            ::apache::thrift::protocol::TType _vtype7;
            xfer += iprot->readMapBegin(_ktype6, _vtype7, _size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              std::string _key10;
              xfer += iprot->readString(_key10);
              std::string& _val11 = this->parameters[_key10];
              xfer += iprot->readString(_val11);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isActual);
          this->__isset.isActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TEvent");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter12;
    for (_iter12 = this->parameters.begin(); _iter12 != this->parameters.end(); ++_iter12)
    {
      xfer += oprot->writeString(_iter12->first);
      xfer += oprot->writeString(_iter12->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isActual", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isActual);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TEvent &a, TEvent &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.parameters, b.parameters);
  swap(a.isActual, b.isActual);
  swap(a.__isset, b.__isset);
}

TEvent::TEvent(const TEvent& other13) {
  name = other13.name;
  parameters = other13.parameters;
  isActual = other13.isActual;
  __isset = other13.__isset;
}
TEvent& TEvent::operator=(const TEvent& other14) {
  name = other14.name;
  parameters = other14.parameters;
  isActual = other14.isActual;
  __isset = other14.__isset;
  return *this;
}
void TEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TEvent(";
  out << "name=" << to_string(name);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "isActual=" << to_string(isActual);
  out << ")";
}


TResponse::~TResponse() throw() {
}


void TResponse::__set_status(const TStatus::type val) {
  this->status = val;
}

void TResponse::__set_executeEvents(const std::vector<TEvent> & val) {
  this->executeEvents = val;
__isset.executeEvents = true;
}

void TResponse::__set_modifiedEvent(const TEvent& val) {
  this->modifiedEvent = val;
__isset.modifiedEvent = true;
}

void TResponse::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

uint32_t TResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->status = (TStatus::type)ecast15;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->executeEvents.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->executeEvents.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->executeEvents[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.executeEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modifiedEvent.read(iprot);
          this->__isset.modifiedEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.executeEvents) {
    xfer += oprot->writeFieldBegin("executeEvents", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->executeEvents.size()));
      std::vector<TEvent> ::const_iterator _iter21;
      for (_iter21 = this->executeEvents.begin(); _iter21 != this->executeEvents.end(); ++_iter21)
      {
        xfer += (*_iter21).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.modifiedEvent) {
    xfer += oprot->writeFieldBegin("modifiedEvent", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->modifiedEvent.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResponse &a, TResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.executeEvents, b.executeEvents);
  swap(a.modifiedEvent, b.modifiedEvent);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

TResponse::TResponse(const TResponse& other22) {
  status = other22.status;
  executeEvents = other22.executeEvents;
  modifiedEvent = other22.modifiedEvent;
  comment = other22.comment;
  __isset = other22.__isset;
}
TResponse& TResponse::operator=(const TResponse& other23) {
  status = other23.status;
  executeEvents = other23.executeEvents;
  modifiedEvent = other23.modifiedEvent;
  comment = other23.comment;
  __isset = other23.__isset;
  return *this;
}
void TResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResponse(";
  out << "status=" << to_string(status);
  out << ", " << "executeEvents="; (__isset.executeEvents ? (out << to_string(executeEvents)) : (out << "<null>"));
  out << ", " << "modifiedEvent="; (__isset.modifiedEvent ? (out << to_string(modifiedEvent)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ")";
}


TPxpSpec::~TPxpSpec() throw() {
}


void TPxpSpec::__set_ip(const std::string& val) {
  this->ip = val;
}

void TPxpSpec::__set_port(const tint val) {
  this->port = val;
}

void TPxpSpec::__set_description(const std::string& val) {
  this->description = val;
}

void TPxpSpec::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t TPxpSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPxpSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPxpSpec");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPxpSpec &a, TPxpSpec &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.description, b.description);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TPxpSpec::TPxpSpec(const TPxpSpec& other24) {
  ip = other24.ip;
  port = other24.port;
  description = other24.description;
  id = other24.id;
  __isset = other24.__isset;
}
TPxpSpec& TPxpSpec::operator=(const TPxpSpec& other25) {
  ip = other25.ip;
  port = other25.port;
  description = other25.description;
  id = other25.id;
  __isset = other25.__isset;
  return *this;
}
void TPxpSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPxpSpec(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ", " << "description=" << to_string(description);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


TContainer::~TContainer() throw() {
}


void TContainer::__set_id(const std::string& val) {
  this->id = val;
}

void TContainer::__set_attributes(const std::vector<TAttribute> & val) {
  this->attributes = val;
}

uint32_t TContainer::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_attributes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributes.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->attributes.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->attributes[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_attributes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TContainer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TContainer");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->attributes.size()));
    std::vector<TAttribute> ::const_iterator _iter31;
    for (_iter31 = this->attributes.begin(); _iter31 != this->attributes.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TContainer &a, TContainer &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.attributes, b.attributes);
}

TContainer::TContainer(const TContainer& other32) {
  id = other32.id;
  attributes = other32.attributes;
}
TContainer& TContainer::operator=(const TContainer& other33) {
  id = other33.id;
  attributes = other33.attributes;
  return *this;
}
void TContainer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TContainer(";
  out << "id=" << to_string(id);
  out << ", " << "attributes=" << to_string(attributes);
  out << ")";
}


TData::~TData() throw() {
}


void TData::__set_id(const std::string& val) {
  this->id = val;
}

uint32_t TData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TData &a, TData &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

TData::TData(const TData& other34) {
  id = other34.id;
}
TData& TData::operator=(const TData& other35) {
  id = other35.id;
  return *this;
}
void TData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TData(";
  out << "id=" << to_string(id);
  out << ")";
}


TName::~TName() throw() {
}


void TName::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t TName::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TName");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TName &a, TName &b) {
  using ::std::swap;
  swap(a.name, b.name);
}

TName::TName(const TName& other36) {
  name = other36.name;
}
TName& TName::operator=(const TName& other37) {
  name = other37.name;
  return *this;
}
void TName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TName(";
  out << "name=" << to_string(name);
  out << ")";
}


TXmlPolicy::~TXmlPolicy() throw() {
}


void TXmlPolicy::__set_name(const std::string& val) {
  this->name = val;
}

void TXmlPolicy::__set_xml(const std::string& val) {
  this->xml = val;
}

void TXmlPolicy::__set_description(const std::string& val) {
  this->description = val;
}

void TXmlPolicy::__set_templateId(const std::string& val) {
  this->templateId = val;
}

void TXmlPolicy::__set_templateXml(const std::string& val) {
  this->templateXml = val;
}

void TXmlPolicy::__set_dataClass(const std::string& val) {
  this->dataClass = val;
}

uint32_t TXmlPolicy::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_xml = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xml);
          isset_xml = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->templateId);
          this->__isset.templateId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->templateXml);
          this->__isset.templateXml = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataClass);
          this->__isset.dataClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_xml)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TXmlPolicy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TXmlPolicy");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xml", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->xml);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("templateId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->templateId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("templateXml", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->templateXml);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataClass", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dataClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TXmlPolicy &a, TXmlPolicy &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.xml, b.xml);
  swap(a.description, b.description);
  swap(a.templateId, b.templateId);
  swap(a.templateXml, b.templateXml);
  swap(a.dataClass, b.dataClass);
  swap(a.__isset, b.__isset);
}

TXmlPolicy::TXmlPolicy(const TXmlPolicy& other38) {
  name = other38.name;
  xml = other38.xml;
  description = other38.description;
  templateId = other38.templateId;
  templateXml = other38.templateXml;
  dataClass = other38.dataClass;
  __isset = other38.__isset;
}
TXmlPolicy& TXmlPolicy::operator=(const TXmlPolicy& other39) {
  name = other39.name;
  xml = other39.xml;
  description = other39.description;
  templateId = other39.templateId;
  templateXml = other39.templateXml;
  dataClass = other39.dataClass;
  __isset = other39.__isset;
  return *this;
}
void TXmlPolicy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TXmlPolicy(";
  out << "name=" << to_string(name);
  out << ", " << "xml=" << to_string(xml);
  out << ", " << "description=" << to_string(description);
  out << ", " << "templateId=" << to_string(templateId);
  out << ", " << "templateXml=" << to_string(templateXml);
  out << ", " << "dataClass=" << to_string(dataClass);
  out << ")";
}


TPtpResponse::~TPtpResponse() throw() {
}


void TPtpResponse::__set_policy(const TXmlPolicy& val) {
  this->policy = val;
}

void TPtpResponse::__set_status(const TStatus::type val) {
  this->status = val;
}

void TPtpResponse::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t TPtpResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->policy.read(iprot);
          this->__isset.policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->status = (TStatus::type)ecast40;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPtpResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPtpResponse");

  xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->policy.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPtpResponse &a, TPtpResponse &b) {
  using ::std::swap;
  swap(a.policy, b.policy);
  swap(a.status, b.status);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TPtpResponse::TPtpResponse(const TPtpResponse& other41) {
  policy = other41.policy;
  status = other41.status;
  message = other41.message;
  __isset = other41.__isset;
}
TPtpResponse& TPtpResponse::operator=(const TPtpResponse& other42) {
  policy = other42.policy;
  status = other42.status;
  message = other42.message;
  __isset = other42.__isset;
  return *this;
}
void TPtpResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPtpResponse(";
  out << "policy=" << to_string(policy);
  out << ", " << "status=" << to_string(status);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


TobiasEvent::~TobiasEvent() throw() {
}


void TobiasEvent::__set_name(const std::string& val) {
  this->name = val;
}

void TobiasEvent::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

uint32_t TobiasEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              std::string& _val49 = this->parameters[_key48];
              xfer += iprot->readString(_val49);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TobiasEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TobiasEvent");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter50;
    for (_iter50 = this->parameters.begin(); _iter50 != this->parameters.end(); ++_iter50)
    {
      xfer += oprot->writeString(_iter50->first);
      xfer += oprot->writeString(_iter50->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TobiasEvent &a, TobiasEvent &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

TobiasEvent::TobiasEvent(const TobiasEvent& other51) {
  name = other51.name;
  parameters = other51.parameters;
  __isset = other51.__isset;
}
TobiasEvent& TobiasEvent::operator=(const TobiasEvent& other52) {
  name = other52.name;
  parameters = other52.parameters;
  __isset = other52.__isset;
  return *this;
}
void TobiasEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TobiasEvent(";
  out << "name=" << to_string(name);
  out << ", " << "parameters=" << to_string(parameters);
  out << ")";
}


TobiasResponse::~TobiasResponse() throw() {
}


void TobiasResponse::__set_status(const TobiasStatusType::type val) {
  this->status = val;
}

void TobiasResponse::__set_executeEvents(const std::vector<TobiasEvent> & val) {
  this->executeEvents = val;
__isset.executeEvents = true;
}

void TobiasResponse::__set_modifiedEvents(const TobiasEvent& val) {
  this->modifiedEvents = val;
__isset.modifiedEvents = true;
}

uint32_t TobiasResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast53;
          xfer += iprot->readI32(ecast53);
          this->status = (TobiasStatusType::type)ecast53;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->executeEvents.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->executeEvents.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->executeEvents[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.executeEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->modifiedEvents.read(iprot);
          this->__isset.modifiedEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TobiasResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TobiasResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.executeEvents) {
    xfer += oprot->writeFieldBegin("executeEvents", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->executeEvents.size()));
      std::vector<TobiasEvent> ::const_iterator _iter59;
      for (_iter59 = this->executeEvents.begin(); _iter59 != this->executeEvents.end(); ++_iter59)
      {
        xfer += (*_iter59).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.modifiedEvents) {
    xfer += oprot->writeFieldBegin("modifiedEvents", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->modifiedEvents.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TobiasResponse &a, TobiasResponse &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.executeEvents, b.executeEvents);
  swap(a.modifiedEvents, b.modifiedEvents);
  swap(a.__isset, b.__isset);
}

TobiasResponse::TobiasResponse(const TobiasResponse& other60) {
  status = other60.status;
  executeEvents = other60.executeEvents;
  modifiedEvents = other60.modifiedEvents;
  __isset = other60.__isset;
}
TobiasResponse& TobiasResponse::operator=(const TobiasResponse& other61) {
  status = other61.status;
  executeEvents = other61.executeEvents;
  modifiedEvents = other61.modifiedEvents;
  __isset = other61.__isset;
  return *this;
}
void TobiasResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TobiasResponse(";
  out << "status=" << to_string(status);
  out << ", " << "executeEvents="; (__isset.executeEvents ? (out << to_string(executeEvents)) : (out << "<null>"));
  out << ", " << "modifiedEvents="; (__isset.modifiedEvents ? (out << to_string(modifiedEvents)) : (out << "<null>"));
  out << ")";
}

}}}}}}} // namespace
